/***********************************************
 * Decompiled by ATE47 and Edited by SyndiShanX
 * Script: killstreaks\ai_tank_shared.gsc
***********************************************/

#include script_52d2de9b438adc78;
#include scripts\abilities\ability_player;
#include scripts\autogenerated\luielems\core\multi_stage_target_lockon;
#include scripts\core_common\ai\archetype_damage_utility;
#include scripts\core_common\ai\blackboard_vehicle;
#include scripts\core_common\ai\systems\blackboard;
#include scripts\core_common\ai_shared;
#include scripts\core_common\array_shared;
#include scripts\core_common\callbacks_shared;
#include scripts\core_common\challenges_shared;
#include scripts\core_common\clientfield_shared;
#include scripts\core_common\gameobjects_shared;
#include scripts\core_common\globallogic\globallogic_score;
#include scripts\core_common\lui_shared;
#include scripts\core_common\math_shared;
#include scripts\core_common\oob;
#include scripts\core_common\player\player_stats;
#include scripts\core_common\struct;
#include scripts\core_common\targetting_delay;
#include scripts\core_common\throttle_shared;
#include scripts\core_common\turret_shared;
#include scripts\core_common\util_shared;
#include scripts\core_common\values_shared;
#include scripts\core_common\vehicle_ai_shared;
#include scripts\core_common\vehicle_death_shared;
#include scripts\core_common\vehicle_shared;
#include scripts\core_common\visionset_mgr_shared;
#include scripts\core_common\weapons_shared;
#include scripts\killstreaks\airsupport;
#include scripts\killstreaks\emp_shared;
#include scripts\killstreaks\killstreak_bundles;
#include scripts\killstreaks\killstreak_hacking;
#include scripts\killstreaks\killstreakrules_shared;
#include scripts\killstreaks\killstreaks_shared;
#include scripts\killstreaks\killstreaks_util;
#include scripts\killstreaks\remote_weapons;
#include scripts\weapons\heatseekingmissile;

#namespace ai_tank;

init_shared(bundlename) {
  if(!isDefined(level.var_400ded61)) {
    level.var_400ded61 = {};
    ir_strobe::init_shared();
    remote_weapons::init_shared();
    airsupport::init_shared();

    if(!isDefined(bundlename)) {
      bundlename = "killstreak_tank_robot";
    }

    level.var_aca462a0 = [];

    if(!(isDefined(level.var_9f011465) && level.var_9f011465)) {
      for(ti = 0; ti < 5; ti++) {
        level.var_aca462a0[ti] = multi_stage_target_lockon::register("multi_stage_target_lockon" + ti);
      }
    }

    bundle = struct::get_script_bundle("killstreak", bundlename);
    level.var_400ded61.aitankkillstreakbundle = bundle;
    killstreaks::register_bundle(bundle, &usekillstreakaitankdrop);
    killstreaks::register_remote_override_weapon("tank_robot", "killstreak_ai_tank");
    killstreaks::function_e37b061("tank_robot", getweapon(#"tank_robot_launcher_turret"));
    ir_strobe::function_8806675d(#"ai_tank_marker", &spawn_tank_robot);
    level.killstreaks[#"tank_robot"].threatonkill = 1;

    if(function_8b1a219a()) {
      remote_weapons::registerremoteweapon("killstreak_ai_tank", #"hash_3abd55f34c1661ac", &starttankremotecontrol, &endtankremotecontrol, 1);
    } else {
      remote_weapons::registerremoteweapon("killstreak_ai_tank", #"hash_747fc4429380f380", &starttankremotecontrol, &endtankremotecontrol, 1);
    }

    level.var_66e94ad5 = bundle.ksweapon;
    level.ai_tank_damage_fx = "killstreaks/fx8_drone_tank_damage_state";
    level.ai_tank_explode_fx = "killstreaks/fx8_agr_explosion";
    level.ai_tank_crate_explode_fx = "killstreaks/fx8_agr_drop_box";

    if(!isDefined(bundle.ksmainturretrecoilforcezoffset)) {
      bundle.ksmainturretrecoilforcezoffset = 0;
    }

    if(!isDefined(bundle.ksweaponreloadtime)) {
      bundle.ksweaponreloadtime = 0.5;
    }

    visionset_mgr::register_info("visionset", "agr_visionset", 1, 80, 16, 1, &visionset_mgr::ramp_in_out_thread_per_player_death_shutdown, 0);
    callback::on_spawned(&on_player_spawned);
    function_61610d6b();
    thread register();

    if(!isDefined(level.var_950314f5)) {
      level.var_950314f5 = new throttle();
      [
        [level.var_950314f5]
      ] - > initialize(1, 0.5);
    }
  }

  callback::on_finalize_initialization(&function_1c601b99);
}

function_1c601b99() {
  if(isDefined(level.var_a5dacbea)) {
    [[level.var_a5dacbea]](getweapon("ai_tank_marker"), &function_127fb8f3);
  }
}

function_1210a3d6(mantis) {
  mantis endon(#"death");

  if(isDefined(level.var_5d492b75)) {
    [[level.var_5d492b75]](mantis, 1);
  }

  wait 3;

  if(!isDefined(mantis)) {
    return;
  }

  if(isDefined(level.var_5d492b75)) {
    [[level.var_5d492b75]](mantis, 0);
  }
}

function_127fb8f3(mantis, attackingplayer) {
  if(isDefined(level.var_1794f85f)) {
    [[level.var_1794f85f]](attackingplayer, "disrupted_mantis");
  }

  if(!(isDefined(mantis.isstunned) && mantis.isstunned)) {
    mantis thread tank_stun(3, 1);
    mantis thread function_1210a3d6(mantis);
  }

  return true;
}

on_player_spawned() {
  if(isDefined(level.var_66e94ad5) && !self hasweapon(level.var_66e94ad5)) {
    self clientfield::set_player_uimodel("hudItems.tankState", 0);
  }

  foreach(player in level.players) {
    if(!isDefined(player)) {
      continue;
    }

    if(self.team == player.team) {
      continue;
    }

    if(isDefined(player.ai_tank_drone)) {
      player.ai_tank_drone respectnottargetedbyaitankperk(self);
    }
  }

  cleanup_targeting(self);
}

function_61610d6b() {
  level.var_51368c39 = struct::get_array("datapad_loc", "targetname");

  foreach(point in level.var_51368c39) {
    point.objectiveid = gameobjects::get_next_obj_id();
    objective_add(point.objectiveid, "invisible", point.origin, #"datapad_location");
    objective_setinvisibletoall(point.objectiveid);
  }

  var_9afbe37 = struct::get_array("datapad_patrol_loc", "targetname");

  foreach(point in var_9afbe37) {
    point.objectiveid = gameobjects::get_next_obj_id();
    objective_add(point.objectiveid, "invisible", point.origin, #"hash_60fb0be7a198b305");
    objective_setinvisibletoall(point.objectiveid);

    if(!isDefined(level.var_51368c39)) {
      level.var_51368c39 = [];
    } else if(!isarray(level.var_51368c39)) {
      level.var_51368c39 = array(level.var_51368c39);
    }

    level.var_51368c39[level.var_51368c39.size] = point;
  }
}

register() {
  clientfield::register("vehicle", "ai_tank_death", 1, 1, "int");
  clientfield::register("vehicle", "ai_tank_immobile", 1, 1, "int");
  clientfield::register("vehicle", "ai_tank_change_control", 1, 1, "int");
  clientfield::register("toplayer", "ai_tank_update_hud", 1, 1, "counter");
  clientfield::register("clientuimodel", "hudItems.tankState", 1, 3, "int");
  clientfield::register("toplayer", "ai_tank_jam_hud", 9000, 1, "int");
}

function_203098f4(waittime) {
  self endon(#"disconnect");
  wait waittime;
  lui::screen_fade_in(0);
}

watchforentervehicle() {
  self endon(#"emp_jammed", #"emp_grenaded", #"disconnect", #"confirm_location", #"cancel_location");
  self waittill(#"enter_vehicle");

  if(self remote_weapons::allowremotestart(1) && isDefined(self.ai_tank_drone)) {
    thread function_203098f4(3);
    lui::screen_fade_out(0.1);
    self thread remote_weapons::useremoteweapon(self.ai_tank_drone, "killstreak_ai_tank", 1, 1, 1);
  }
}

function_d49c17b9() {
  self clientfield::set_player_uimodel("locSel.snapTo", 1);
  self function_35ad808a("map_directional_selector");
  self.selectinglocation = 1;
  self thread airsupport::endselectionthink();
}

function_3b8d91fd() {
  self function_d49c17b9();
  self clientfield::set_player_uimodel("locSel.commandMode", 0);
}

function_c3d60d1c() {
  self function_d49c17b9();
  self clientfield::set_player_uimodel("locSel.commandMode", 1);
}

islocselincommandmode() {
  return self clientfield::get_player_uimodel("locSel.commandMode") == 1;
}

usekillstreakaitankdrop(killstreaktype) {
  team = self.team;
  waterdepth = self depthofplayerinwater();

  if(!self isonground() || self util::isusingremote() || waterdepth > 2) {
    self iprintlnbold(#"hash_ec04d7a9114ba0e");
    return 0;
  }

  if(isDefined(level.var_30264985)) {
    level notify(#"marker_ready");
    waitresult = self waittill(#"mantis_deployed", #"death", #"weapon_change", #"weapon_fired");
  }

  context = spawnStruct();
  context.radius = level.killstreakcorebundle.ksairdropsupplydropradius;
  context.dist_from_boundary = 50;
  context.max_dist_from_location = 4;
  context.perform_physics_trace = 1;
  context.islocationgood = &islocationgood;
  context.objective = #"hash_1b5a86007f598bbc";
  context.validlocationsound = level.killstreakcorebundle.ksvalidcarepackagelocationsound;
  context.tracemask = 1 | 4;
  context.droptag = "tag_cargo_attach";
  context.killstreaktype = #"ai_tank_marker";
  context.killstreakref = "tank_robot";
  context.dontdisconnectpaths = 1;
  context.var_655d53ec = 1;
  return self ir_strobe::function_f625256f(undefined, context);
}

spawn_tank_robot(owner, context, origin) {
  location = spawnStruct();
  location.origin = origin;
  owner clientfield::set_player_uimodel("hudItems.tankState", 1);
  owner airsupport::function_83904681(location, &function_e1553d5f);
}

function_4c0ed253(location, context) {
  if(!self killstreakrules::iskillstreakallowed("tank_robot", self.team, 1)) {
    return false;
  }

  foreach(droplocation in level.droplocations) {
    if(distance2dsquared(droplocation, location) < 3600) {
      return false;
    }
  }

  if(context.perform_physics_trace === 1) {
    mask = 1;

    if(isDefined(context.tracemask)) {
      mask = context.tracemask;
    }

    radius = context.radius;
    trace = physicstrace(location + (0, 0, 5000), location + (0, 0, 30), (radius * -1, radius * -1, 0), (radius, radius, 2 * radius), undefined, mask);

    if(trace[#"fraction"] < 1) {
      if(!(isDefined(level.var_66da9c3c) && level.var_66da9c3c)) {
        return false;
      }
    }
  }

  result = function_9cc082d2(location + (0, 0, 100), 170);

  if(!isDefined(result)) {
    return false;
  }

  if(context.check_same_floor === 1 && abs(location[2] - self.origin[2]) > 96) {
    return false;
  }

  return true;
}

islocationgood(location, context) {
  if(getdvarint(#"hash_458cd0a10d30cedb", 1)) {
    return function_4c0ed253(location, context);
  }

  if(!self killstreakrules::iskillstreakallowed("tank_robot", self.team, 1)) {
    return 0;
  }

  foreach(droplocation in level.droplocations) {
    if(distance2dsquared(droplocation, location) < 3600) {
      return 0;
    }
  }

  if(context.perform_physics_trace === 1) {
    mask = 1;

    if(isDefined(context.tracemask)) {
      mask = context.tracemask;
    }

    radius = context.radius;
    trace = physicstrace(location + (0, 0, 5000), location + (0, 0, 10), (radius * -1, radius * -1, 0), (radius, radius, 2 * radius), undefined, mask);

    if(trace[#"fraction"] < 1) {
      if(!(isDefined(level.var_66da9c3c) && level.var_66da9c3c)) {
        return 0;
      }
    }
  }

  isvalidpoint = 1;

  if(ispointonnavmesh(location, context.dist_from_boundary)) {
    closestpoint = getclosestpointonnavmesh(location, max(context.max_dist_from_location, 24), context.dist_from_boundary);
    isvalidpoint = isDefined(closestpoint);

    if(isvalidpoint && context.check_same_floor === 1 && abs(location[2] - closestpoint[2]) > 96) {
      isvalidpoint = 0;
    }
  } else {
    isvalidpoint = 0;
  }

  if(getdvarint(#"scr_supply_drop_valid_location_debug", 0)) {
    if(!isvalidpoint) {
      otherclosestpoint = getclosestpointonnavmesh(location, getdvarfloat(#"scr_supply_drop_valid_location_radius_debug", 96), context.dist_from_boundary);

      if(isDefined(otherclosestpoint)) {
        sphere(otherclosestpoint, context.max_dist_from_location, (1, 0, 0), 0.8, 0, 20, 1);
      }
    } else {
      sphere(closestpoint, context.max_dist_from_location, (0, 1, 0), 0.8, 0, 20, 1);
      util::drawcylinder(closestpoint, context.radius, 8000, 0.0166667, undefined, (0, 0.9, 0), 0.7);
    }
  }

    return isvalidpoint;
}

function_5479b133(team, killstreak_id) {
  self endon(#"payload_delivered", #"disconnect", #"joined_team", #"joined_spectators", #"changed_specialist");
  self waittill(#"payload_fail");
  self killstreakrules::killstreakstop("tank_robot", team, killstreak_id);
}

function_b60b8174() {
  self endon(#"death", #"changed_specialist", #"disconnect", #"joined_team", #"joined_spectators");
  killstreakweapon = killstreaks::get_killstreak_weapon("tank_robot");

  while(true) {
    quantity = killstreaks::get_killstreak_quantity(killstreakweapon);

    if(quantity === 0) {
      break;
    }

    waitframe(1);
  }

  killstreaks::change_killstreak_quantity(killstreakweapon, 1);
}

function_e1553d5f(location, killstreak_id) {
  team = self.team;
  killstreak_id = self killstreakrules::killstreakstart("tank_robot", team, 0, 1);

  if(killstreak_id == -1) {
    return false;
  }

  bundle = level.var_400ded61.aitankkillstreakbundle;
  killstreak = killstreaks::get_killstreak_for_weapon(bundle.ksweapon);
  context = spawnStruct();

  if(!isDefined(context)) {
    killstreak_stop_and_assert(killstreak, team, killstreak_id, "Failed to spawn struct for ai tank.");
    return false;
  }

  self ability_player::function_c22f319e(bundle.ksweapon);
  context.radius = level.killstreakcorebundle.ksairdropaitankradius;
  context.dist_from_boundary = 50;
  context.max_dist_from_location = 4;
  context.perform_physics_trace = 1;
  context.selectedlocation = location;
  context.islocationgood = &is_location_good;
  context.objective = #"airdrop_aitank";
  context.killstreakref = killstreak;
  context.validlocationsound = level.killstreakcorebundle.ksvalidaitanklocationsound;
  context.vehiclename = #"vehicle_t8_mil_helicopter_transport_mp";
  context.tracemask = 1 | 4;
  context.droptag = "tag_cargo_attach";
  context.var_9fc6cfe9 = 1;
  context.dontdisconnectpaths = 1;

  if(!isDefined(level.var_daa33d93)) {
    return false;
  }

  result = [[level.var_daa33d93]](killstreak_id, context, team);

  if(!(isDefined(result) && result)) {
    killstreakrules::killstreakstop("tank_robot", team, killstreak_id);
    return false;
  }

  self thread function_e00df756(team, killstreak_id);
  self stats::function_e24eec31(bundle.ksweapon, #"used", 1);
  return true;
}

function_e00df756(team, killstreak_id) {
  self notify("40dbfe8fe71109dc");
  self endon("40dbfe8fe71109dc");
  player = self;
  player endon(#"tank_robot");
  player waittill(#"changed_specialist", #"disconnect", #"joined_team", #"joined_spectators");
  killstreakrules::killstreakstop("tank_robot", team, killstreak_id);
}

function_b2acf3f2(location, context) {
  if(!ispointonnavmesh(location)) {

    recordsphere(location + (0, 0, 10), 2, (1, 0, 0), "<dev string:x38>");

      return false;
  }

  var_8a7edebd = 5;
  depth = getwaterheight(location) - self.origin[2];
  inwater = depth > var_8a7edebd;

  if(inwater) {
    return false;
  }

  return true;
}

crateland(crate, category, owner, team, context) {
  owner notify(#"tank_robot");
  context.perform_physics_trace = 0;
  context.dist_from_boundary = 50;
  context.max_dist_from_location = 96;

  if(!crate function_b2acf3f2(crate.origin, context) || !isDefined(owner) || util::function_fbce7263(team, owner.team) || owner emp::enemyempactive() && !owner hasperk(#"specialty_immuneemp")) {
    killstreakrules::killstreakstop(category, team, crate.package_contents_id);
    wait 10;

    if(isDefined(level.var_30264985)) {
      level.var_cf82598a = 1;
    }

    if(isDefined(crate)) {
      crate delete();
    }

    return;
  }

  origin = crate.origin;

  if(isDefined(level.var_5ef874c8) && level.var_5ef874c8) {
    radius = 5;
    mask = 1 | 4;
    cratebottom = physicstrace(origin + (0, 0, 25), origin + (0, 0, -50), (radius * -1, radius * -1, 0), (radius, radius, 2 * radius), crate, mask);
  } else {
    cratebottom = bulletTrace(origin, origin + (0, 0, -50), 0, crate);
  }

  if(isDefined(cratebottom)) {
    origin = cratebottom[#"position"] + (0, 0, 1);
  }

  playFX(level.ai_tank_crate_explode_fx, origin, (1, 0, 0), (0, 0, 1));
  playsoundatposition(#"veh_talon_crate_exp", crate.origin);
  level thread ai_tank_killstreak_start(owner, origin, crate.package_contents_id, category, undefined, context);

  if(!isDefined(context.vehicle)) {
    crate delete();
  }
}

is_location_good(location, context) {
  return true;
}

hackedcallbackpre(hacker) {
  drone = self;
  drone clientfield::set("enemyvehicle", 2);
  drone.owner stop_remote();
  drone.owner clientfield::set_to_player("static_postfx", 0);

  if(drone.controlled === 1) {
    visionset_mgr::deactivate("visionset", "agr_visionset", drone.owner);
  }

  drone.owner remote_weapons::removeandassignnewremotecontroltrigger(drone.usetrigger);
  drone remote_weapons::endremotecontrolweaponuse(1);
  drone.owner unlink();
  drone clientfield::set("vehicletransition", 0);
}

hackedcallbackpost(hacker) {
  drone = self;
  hacker remote_weapons::useremoteweapon(drone, "killstreak_ai_tank", 0);
  drone notify(#"watchremotecontroldeactivate_remoteweapons");
  drone.killstreak_end_time = hacker killstreak_hacking::set_vehicle_drivable_time_starting_now(drone);
}

configureteampost(owner, ishacked) {
  drone = self;
  drone thread tank_watch_owner_events();
}

function_9b13ebf(drone) {
  drone useanimtree("generic");
  vehicle::make_targetable(drone);
  blackboard::createblackboardforentity(drone);
  drone blackboard::registervehicleblackboardattributes();
  drone.health = drone.healthdefault;
  drone vehicle::friendly_fire_shield();
  drone enableaimassist();
  drone setneargoalnotifydist(40);
  drone setplayercollision(0);
  drone setavoidancemask("avoid none");
  drone.fovcosine = 0;
  drone.fovcosinebusy = 0.574;
  assert(isDefined(drone.scriptbundlesettings));
  drone.settings = struct::get_script_bundle("vehiclecustomsettings", drone.scriptbundlesettings);
  drone.goalheight = 512;
  drone setgoal(drone.origin, 0, drone.goalradius, drone.goalheight);
  drone.delete_on_death = 1;
  drone.no_free_on_death = 1;
  drone.overridevehicledamage = &drone_callback_damage;
  drone thread vehicle_ai::nudge_collision();
  drone.cobra = 0;
  drone asmrequestsubstate(#"locomotion@movement");
  drone.variant = "light_weight";
  drone.var_a8c60b0e = 1;
  drone.var_b4c9d62 = 1;
  drone.var_527f38dc = 0;
  drone util::cooldown("cobra_up", 10);
  drone.var_232915af = 1;
  drone.var_6e9e073d = 1;
  drone vehicle_ai::init_state_machine_for_role("default");
  drone vehicle_ai::get_state_callbacks("combat").enter_func = &state_combat_enter;
  drone.identifier_weapon = getweapon("ai_Tank_marker");

  if(drone.vehicletype == #"archetype_mini_quadtank_ct") {
    drone vehicle_ai::get_state_callbacks("combat").update_func = &function_dd91d091;
  } else {
    drone vehicle_ai::get_state_callbacks("combat").update_func = &state_combat_update;
  }

  drone vehicle_ai::get_state_callbacks("driving").update_func = &state_driving_update;
  drone vehicle_ai::get_state_callbacks("driving").exit_func = &function_481e984f;
  drone vehicle_ai::get_state_callbacks("emped").update_func = &state_emped_update;
  drone vehicle_ai::get_state_callbacks("death").update_func = &state_death_update;

  if(isDefined(level.var_30264985)) {
    drone vehicle_ai::startinitialstate("scripted");
  } else {
    drone vehicle_ai::startinitialstate("combat");
  }

  drone thread targetting_delay::function_7e1a12ce(level.killstreakbundle[#"tank_robot"].var_2aeadfa0);
}

drone_callback_damage(einflictor, eattacker, idamage, idflags, smeansofdeath, weapon, vpoint, vdir, shitloc, vdamageorigin, psoffsettime, damagefromunderneath, modelindex, partname, vsurfacenormal) {
  idamage = vehicle_ai::shared_callback_damage(einflictor, eattacker, idamage, idflags, smeansofdeath, weapon, vpoint, vdir, shitloc, vdamageorigin, psoffsettime, damagefromunderneath, modelindex, partname, vsurfacenormal);
  return idamage;
}

function_75c8a0dc(entity, jammer) {

  print("<dev string:x41>");

    if(!(isDefined(entity.isstunned) && entity.isstunned)) {
      entity function_903fdcc2();
      entity function_4110f8dd(1);
    }

  return true;
}

function_3dc3ca04(entity, jammer) {

  print("<dev string:x5b>");

    entity function_37b0973();
  entity function_fd91abfb();
}

ai_tank_killstreak_start(owner, origin, killstreak_id, category, tankarchetype, context) {
  team = owner.team;
  waittillframeend();

  if(level.gameended) {
    return;
  }

  if(!isDefined(tankarchetype)) {
    tankarchetype = #"archetype_mini_quadtank_mp";
  }

  if(isDefined(context) && isDefined(context.vehicle)) {
    drone = context.vehicle;
  } else {
    drone = spawnvehicle(tankarchetype, origin + (0, 0, 40), (0, 0, 0), "talon", undefined, 1, owner);
  }

  drone killstreak_bundles::spawned(level.killstreakbundle[#"tank_robot"]);

  if(!isDefined(drone)) {
    killstreak_stop_and_assert(category, team, killstreak_id, "Failed to spawn ai tank vehicle.");
    return;
  }

  function_9b13ebf(drone);
  owner clientfield::set_player_uimodel("hudItems.tankState", 2);
  drone.settings = struct::get_script_bundle("vehiclecustomsettings", drone.scriptbundlesettings);
  drone.isstunned = 0;
  drone.var_b61a6415 = 0;
  aiutility::addaioverridedamagecallback(drone, &function_4f8d11b);
  drone.customdamagemonitor = 1;
  drone.avoid_shooting_owner = 1;
  drone.avoid_shooting_owner_ref_tag = "tag_flash_gunner1";
  drone killstreaks::configure_team("tank_robot", killstreak_id, owner, "small_vehicle", undefined, &configureteampost);
  drone killstreak_hacking::enable_hacking("tank_robot", &hackedcallbackpre, &hackedcallbackpost);
  drone killstreaks::setup_health("tank_robot", 5000, 0);
  drone.original_vehicle_type = drone.vehicletype;
  drone clientfield::set("enemyvehicle", 1);
  drone setvehicleavoidance(1);
  owner clientfield::set_player_uimodel("vehicle.ammoCount", 4);
  drone.killstreak_id = killstreak_id;
  drone.type = "tank_drone";
  drone.dontdisconnectpaths = 1;
  drone.soundmod = "drone_land";
  drone.ignore_vehicle_underneath_splash_scalar = 1;
  drone.treat_owner_damage_as_friendly_fire = 1;
  drone.ignore_team_kills = 1;
  drone.var_b4c9d62 = 1;
  drone.offhand_special = 1;
  drone.var_e9d49a33 = 1;
  drone.goalradius = 250;

  if(isDefined(level.var_1dd2fbe1)) {
    drone[[level.var_1dd2fbe1]]();
  }

  drone.controlled = 0;
  drone makevehicleunusable();
  drone.numberrockets = 4;
  drone.warningshots = 3;
  drone setdrawinfrared(1);
  target_set(drone, (0, 0, 20));
  drone vehicle::init_target_group();
  drone vehicle::add_to_target_group(drone);
  drone setneargoalnotifydist(35);
  drone setup_gameplay_think(category);
  drone.killstreak_end_time = gettime() + 90000;
  params = level.killstreakbundle[#"tank_robot"];
  immediate_use = isDefined(params.ksuseimmediately) ? params.ksuseimmediately : 0;
  waitframe(1);
  owner remote_weapons::useremoteweapon(drone, "killstreak_ai_tank", immediate_use);
  owner.var_976238cf = #"tank_robot";
  owner thread function_47e16e28(drone);
  drone thread kill_monitor();
  drone thread tank_rocket_watch_ai();
  drone callback::function_d8abfc3d(#"on_end_game", &on_end_game);

  if(isDefined(level.var_4b38c02b)) {
    drone[[level.var_4b38c02b]]();
  }

  drone playLoopSound(#"hash_aa65b39680b8d1b");
  owner.ai_tank_drone = drone;

  foreach(player in level.players) {
    drone respectnottargetedbyaitankperk(player);
  }
}

function_47e16e28(weapon) {
  weapon endon(#"remote_weapon_end", #"death");

  while(self.var_976238cf == #"tank_robot") {
    waitframe(1);
  }

  weapon notify(#"remote_weapon_end");
}

function_9868e24e(player) {
  self notify(#"hash_3eddb5faa34443ee");
  self endon(#"hash_3eddb5faa34443ee");
  tank = self;
  self endon(#"death");
  fovcosine = cos(15);
  player.var_6b2d5c29 = [];
  player.var_f1470bda = [];

  for(ti = 0; ti < 5; ti++) {
    player.var_6b2d5c29[ti] = spawnStruct();
    player.var_6b2d5c29[ti].state = 0;
    uifield = level.var_aca462a0[ti];

    if(!uifield multi_stage_target_lockon::is_open(player)) {
      uifield multi_stage_target_lockon::open(player, 1);
    }

    uifield multi_stage_target_lockon::set_entnum(player, player.clientid);
    uifield multi_stage_target_lockon::set_targetstate(player, 0);
  }

  enemies = getplayers();
  ti = 0;

  foreach(enemy in enemies) {
    if(isplayer(enemy) && util::function_fbce7263(player.team, enemy.team)) {
      entnum = enemy getentitynumber();
      player.var_f1470bda[entnum] = ti;
      ti++;

      if(ti >= 5) {
        break;
      }
    }
  }

  while(true) {
    origin = player getplayercamerapos();
    angles = player getplayerangles();
    var_5781dbe = anglesToForward(angles);
    fwd = vectorscale(var_5781dbe, 2000);
    locking = player adsbuttonpressed();
    nlocks = 0;
    enemies = getplayers();

    foreach(target in enemies) {
      if(!isplayer(target) || player.team === target.team) {
        continue;
      }

      if(target hasperk(#"specialty_nokillstreakreticle")) {
        continue;
      }

      var_4ef4e267 = target getentitynumber();
      ti = player.var_f1470bda[var_4ef4e267];

      if(!isDefined(ti)) {
        continue;
      }

      uifield = level.var_aca462a0[ti];
      target_info = player.var_6b2d5c29[ti];

      if(target.ignoreme === 1 || !isalive(target) || self.isjammed === 1) {
        target_info.state = 0;
      } else if(!bullettracepassed(origin, target.origin + (0, 0, 60), 0, player)) {
        target_info.state = 0;
      } else if(target_info.state != 4) {
        if(locking) {
          good = util::within_fov(origin, angles, target.origin, fovcosine);

          if(isDefined(good) && good && nlocks < self.numberrockets) {
            if(target_info.state != 3) {
              if(target_info.state == 2) {
                if(target_info.var_8c0f6d2c < gettime()) {
                  target_info.state = 3;
                  self playsoundtoplayer(#"hash_683ed977cfc2bf2b", player);
                }
              } else {
                target_info.state = 2;
                target_info.var_8c0f6d2c = gettime() + 500;
                self playsoundtoplayer(#"hash_5386a095fd840c2e", player);
              }
            }

            nlocks++;
          } else {
            target_info.state = 1;
          }
        } else {
          target_info.state = 1;
        }
      }

      uifield multi_stage_target_lockon::set_entnum(player, var_4ef4e267);
      uifield multi_stage_target_lockon::set_targetstate(player, target_info.state);
    }

    foreach(target in enemies) {
      var_4ef4e267 = target getentitynumber();
      ti = player.var_f1470bda[var_4ef4e267];

      if(isDefined(ti)) {
        if(!isDefined(target) || !isalive(target)) {
          level.var_aca462a0[ti] multi_stage_target_lockon::set_entnum(player, var_4ef4e267);
          level.var_aca462a0[ti] multi_stage_target_lockon::set_targetstate(player, 0);
          player.var_6b2d5c29[ti].state = 0;
        }
      }
    }

    waitframe(1);
    waitframe(1);
    waitframe(1);
  }
}

function_4f8d11b(einflictor, eattacker, idamage, idflags, smeansofdeath, weapon, vpoint, vdir, shitloc, vdamageorigin, psoffsettime, damagefromunderneath, modelindex, partname, vsurfacenormal) {
  if(isDefined(einflictor) && einflictor == self) {
    return 0;
  }

  if(isDefined(eattacker) && eattacker == self) {
    return 0;
  }

  return idamage;
}

state_death_update(params) {
  self endon(#"death");
  death_type = vehicle_ai::get_death_type(params);

  if(!isDefined(death_type)) {
    params.death_type = "gibbed";
  }

  self vehicle_ai::defaultstate_death_update(params);
}

state_emped_update(params) {
  self endon(#"death", #"change_state");
  angles = self gettagangles("tag_turret");
  self turretsettargetangles(0, (45, angles[1] - self.angles[1], 0));
  angles = self gettagangles("tag_gunner_turret1");
  self turretsettargetangles(1, (45, angles[1] - self.angles[1], 0));
  self vehicle_ai::defaultstate_emped_update(params);
}

state_driving_update(params) {
  self endon(#"change_state", #"death");

  if(isDefined(self.var_b4c9d62) && self.var_b4c9d62) {
    return;
  }

  driver = self getseatoccupant(0);

  if(isplayer(driver)) {
    while(true) {
      driver endon(#"disconnect");
      driver util::waittill_vehicle_move_up_button_pressed();

      if(self.cobra === 0) {
        self cobra_raise();
        continue;
      }

      self cobra_retract();
    }
  }
}

function_481e984f(params) {
  if(isalive(self) && isvehicle(self)) {
    self enableaimassist();
    self.turretrotscale = 1;
    vehicle_ai::clearalllookingandtargeting();
    vehicle_ai::clearallmovement();

    if(!ispointonnavmesh(self.origin, self)) {
      newpos = getclosestpointonnavmesh(self.origin, 500, self getpathfindingradius(), self.var_6e9e073d);

      if(isDefined(newpos)) {
        self.origin = newpos;
      }
    }
  }
}

cobra_raise() {
  if(isDefined(self.var_b4c9d62) && self.var_b4c9d62) {
    return;
  }

  self.cobra = 1;

  if(isDefined(self.settings.cobra_fx_1) && isDefined(self.settings.cobra_tag_1)) {
    playFXOnTag(self.settings.cobra_fx_1, self, self.settings.cobra_tag_1);
  }

  self asmrequestsubstate(#"hash_3e3fc20d5fcbf6e0");
  self vehicle_ai::waittill_asm_complete(#"hash_3e3fc20d5fcbf6e0", 4);
  self laseron();
}

cobra_retract() {
  if(isDefined(self.var_b4c9d62) && self.var_b4c9d62) {
    return;
  }

  self.cobra = 0;
  self laseroff();
  self notify(#"disable_lens_flare");
  self asmrequestsubstate(#"locomotion@movement");
  self vehicle_ai::waittill_asm_complete("locomotion@movement", 4);
}

private state_combat_enter(params) {
  if(!ispointonnavmesh(self.origin) || !ispointonnavmesh(self.origin, 50)) {
    var_8f3583cf = ai::t_cylinder(self.origin, 30, 30);
    goalarray = tacticalquery("ai_tank_wander", self.origin, self, var_8f3583cf);
    goalarray = damage_armor_activati_(self, goalarray);

    if(goalarray.size) {
      goal = arraygetclosest(self.origin, goalarray);

      if(isDefined(goal)) {
        newpos = goal.origin;
      } else {
        goal = array::random(goalarray);
        newpos = goal.origin;
      }
    }

    if(!isDefined(newpos)) {
      newpos = getclosestpointonnavmesh(self.origin, 500, self getpathfindingradius(), self.var_6e9e073d);
    }

    if(isDefined(newpos)) {
      self.origin = newpos;
    }
  }

  self thread function_f358791();
  self thread turretfireupdate();
}

function_f358791() {
  self endon(#"death", #"change_state");
  wait 1;

  for(;;) {
    if(isDefined(self.isstunned) && self.isstunned) {
      self.favoriteenemy = undefined;
      waitframe(1);
      continue;
    }

    targets = [];
    targetsmissile = [];
    players = level.players;

    foreach(player in players) {
      if(self cantargetplayer(player)) {
        targets[targets.size] = player;
      }
    }

    tanks = getEntArray("talon", "targetname");

    foreach(tank in tanks) {
      if(self cantargettank(tank)) {
        targets[targets.size] = tank;
      }
    }

    actors = getactorarray();

    foreach(actor in actors) {
      if(self cantargetactor(actor)) {
        targets[targets.size] = actor;
      }
    }

    self.favoriteenemy = function_b2cc6703(targets);
    waitframe(1);
  }
}

function_b2cc6703(targets) {
  entnum = self getentitynumber();

  for(idx = 0; idx < targets.size; idx++) {
    if(!isDefined(targets[idx].var_629a6b13)) {
      targets[idx].var_629a6b13 = [];
    }

    targets[idx].var_629a6b13[entnum] = 0;

    if(isDefined(targets[idx].type) && targets[idx].type == "dog") {
      update_dog_threat(targets[idx]);
      continue;
    }

    if(isactor(targets[idx])) {
      update_actor_threat(targets[idx]);
      continue;
    }

    if(isplayer(targets[idx])) {
      update_player_threat(targets[idx]);
      continue;
    }

    update_non_player_threat(targets[idx]);
  }

  var_8ec7f501 = undefined;
  highest = -1;

  for(idx = 0; idx < targets.size; idx++) {
    assert(isDefined(targets[idx].var_629a6b13[entnum]), "<dev string:x73>");

    if(targets[idx].var_629a6b13[entnum] >= highest) {
      highest = targets[idx].var_629a6b13[entnum];
      var_8ec7f501 = targets[idx];
    }
  }

  return var_8ec7f501;
}

private update_player_threat(player) {
  entnum = self getentitynumber();
  player.var_629a6b13[entnum] = 0;
  dist = distance(player.origin, self.origin);
  player.var_629a6b13[entnum] -= dist;

  if(isDefined(self.attacker) && player == self.attacker) {
    player.var_629a6b13[entnum] += 100;
  }

  if(isDefined(player.carryobject)) {
    player.var_629a6b13[entnum] += 200;
  }

  if(isDefined(player.score)) {
    player.var_629a6b13[entnum] += player.score * 2;
  }

  if(player weapons::has_launcher()) {
    if(player weapons::has_lockon(self)) {
      player.var_629a6b13[entnum] += 1000;
    } else {
      player.var_629a6b13[entnum] += 500;
    }
  }

  if(player weapons::has_heavy_weapon()) {
    player.var_629a6b13[entnum] += 300;
  }

  if(player weapons::has_lmg()) {
    player.var_629a6b13[entnum] += 200;
  }

  if(isDefined(player.antithreat)) {
    player.var_629a6b13[entnum] -= player.antithreat;
  }

  if(player.var_629a6b13[entnum] <= 0) {
    player.var_629a6b13[entnum] = 2;
  }
}

private update_non_player_threat(non_player) {
  entnum = self getentitynumber();
  non_player.var_629a6b13[entnum] = 0;
  dist = distance(non_player.origin, self.origin);
  non_player.var_629a6b13[entnum] -= dist;

  if(non_player.var_629a6b13[entnum] <= 0) {
    non_player.var_629a6b13[entnum] = 1;
  }
}

private update_actor_threat(actor) {
  entnum = self getentitynumber();
  actor.var_629a6b13[entnum] = 0;
  dist = distance(actor.origin, self.origin);
  actor.var_629a6b13[entnum] -= dist;

  if(isDefined(actor.owner)) {
    if(isDefined(self.attacker) && actor.owner == self.attacker) {
      actor.var_629a6b13[entnum] += 100;
    }

    if(isDefined(actor.owner.carryobject)) {
      actor.var_629a6b13[entnum] += 200;
    }

    if(isDefined(actor.owner.score)) {
      actor.var_629a6b13[entnum] += actor.owner.score * 4;
    }

    if(isDefined(actor.owner.antithreat)) {
      actor.var_629a6b13[entnum] -= actor.owner.antithreat;
    }
  }

  if(actor.var_629a6b13[entnum] <= 0) {
    actor.var_629a6b13[entnum] = 1;
  }
}

private update_dog_threat(dog) {
  entnum = self getentitynumber();
  dog.var_629a6b13[entnum] = 0;
  dist = distance(dog.origin, self.origin);
  dog.var_629a6b13[entnum] -= dist;
}

cantargetplayer(player) {
  if(!isDefined(player)) {
    return false;
  }

  if(!isalive(player) || player.sessionstate != "playing") {
    return false;
  }

  if(player.ignoreme === 1) {
    return false;
  }

  if(isDefined(self.owner) && player == self.owner) {
    return false;
  }

  if(!isDefined(player.team)) {
    return false;
  }

  if(level.teambased && player.team == self.team) {
    return false;
  }

  if(player.team == #"spectator") {
    return false;
  }

  var_2910def0 = self targetting_delay::function_1c169b3a(player);
  targetting_delay::function_a4d6d6d8(player, int((isDefined(self.targeting_delay) ? self.targeting_delay : 0.25) * 1000));

  if(!var_2910def0) {
    return false;
  }

  if(player depthinwater() >= 30 || player isplayerswimming()) {
    return false;
  }

  return true;
}

cantargettank(tank) {
  if(!isDefined(tank)) {
    return false;
  }

  if(!isDefined(tank.team)) {
    return false;
  }

  if(tank.team == self.team) {
    return false;
  }

  if(isDefined(tank.owner) && self.owner == tank.owner) {
    return false;
  }

  return true;
}

cantargetactor(actor) {
  if(!isDefined(actor)) {
    return false;
  }

  if(!isactor(actor)) {
    return false;
  }

  if(!isalive(actor)) {
    return false;
  }

  if(!isDefined(actor.team)) {
    return false;
  }

  if(actor.team == self.team) {
    return false;
  }

  return true;
}

turretfireupdate() {
  self endon(#"death", #"change_state");

  if(!isDefined(self) || !isalive(self) || iscorpse(self)) {
    return;
  }

  weapon = self seatgetweapon(0);

  if(weapon.name == "none") {
    return;
  }

  self turretsetontargettolerance(0, 7);

  while(true) {
    if(self.avoid_shooting_owner === 1 && isDefined(self.owner)) {
      if(self vehicle_ai::owner_in_line_of_fire()) {
        wait 0.1;
        continue;
      }
    }

    if(isalive(self) && !(isDefined(self.isstunned) && self.isstunned) && isDefined(self.enemy)) {
      muzzlepos = self gettagorigin("tag_flash");
      enemyeyepos = self.enemy getEye();
      var_a44b348b = sighttracepassed(muzzlepos, enemyeyepos, 0, self, self.enemy);

      if(var_a44b348b && !function_98a125e6()) {
        self turretsettarget(0, self.enemy);
        self vehlookat(self.enemy);
        waitframe(1);

        if(!self.turretontarget) {
          wait 0.1;
        }

        if(self.turretontarget && isDefined(self.enemy)) {
          self vehicle_ai::fire_for_time(randomfloatrange(self.settings.burstfiredurationmin, self.settings.burstfiredurationmax), 0, self.enemy);
        }

        if(isDefined(self.enemy) && isai(self.enemy)) {
          wait randomfloatrange(self.settings.burstfireaidelaymin, self.settings.burstfireaidelaymax);
        } else {
          wait randomfloatrange(self.settings.burstfiredelaymin, self.settings.burstfiredelaymax);
        }
      }

      wait 1;
      continue;
    }

    wait 1;
  }
}

function_dd91d091(params) {
  self endon(#"change_state", #"death");
  self setspeed(self.settings.defaultmovespeed);
  self setacceleration(isDefined(self.settings.default_move_acceleration) ? self.settings.default_move_acceleration : 10);
  heatseekingmissile::initlockfield(self);

  for(;;) {
    assert(isDefined(self.ai));

    if(!isDefined(self.ai.var_88b0fd29)) {
      self.ai.var_88b0fd29 = gettime();
    }

    var_12cb92c6 = 0;
    goalinfo = self function_4794d6a3();
    newpos = undefined;
    forcedgoal = isDefined(goalinfo.goalforced) && goalinfo.goalforced;
    isatgoal = isDefined(goalinfo.isatgoal) && goalinfo.isatgoal || self isapproachinggoal() && isDefined(self.overridegoalpos);
    itsbeenawhile = isDefined(goalinfo.isatgoal) && goalinfo.isatgoal && gettime() > self.ai.var_88b0fd29;
    var_48ea0381 = 0;
    var_2a8c95a5 = forcedgoal && isDefined(self.overridegoalpos) && distancesquared(self.overridegoalpos, goalinfo.goalpos) < self.radius * self.radius;

    if(isDefined(self.enemy) && !self haspath()) {
      var_48ea0381 = !self seerecently(self.enemy, randomintrange(3, 5));

      if(issentient(self.enemy) || function_ffa5b184(self.enemy)) {
        var_48ea0381 = var_48ea0381 && !self attackedrecently(self.enemy, randomintrange(5, 7));
      }
    }

    var_12cb92c6 = !isatgoal || var_48ea0381 || itsbeenawhile;
    var_12cb92c6 = var_12cb92c6 && !var_2a8c95a5;

    if(var_12cb92c6) {
      if(forcedgoal) {
        newpos = getclosestpointonnavmesh(goalinfo.goalpos, 500, self getpathfindingradius(), self.var_6e9e073d);
      } else {
        goalarray = [];

        if(isDefined(self.enemy)) {
          goalarray = tacticalquery("ai_tank_combat", goalinfo.goalpos, self, self.enemy);
          goalarray = damage_armor_activati_(self, goalarray);
        } else {
          var_8f3583cf = ai::t_cylinder(self.origin, 200, 100);
          goalarray = tacticalquery("ai_tank_wander", goalinfo.goalpos, self, var_8f3583cf);
          goalarray = damage_armor_activati_(self, goalarray);
        }

        var_817e8fd0 = [];

        if(isDefined(goalarray) && goalarray.size) {
          foreach(goal in goalarray) {
            if(!self isingoal(goal.origin)) {
              continue;
            }

            if(isDefined(self.overridegoalpos) && distancesquared(self.overridegoalpos, goal.origin) < 100 * 100) {
              continue;
            }

            var_817e8fd0[var_817e8fd0.size] = goal;
          }

          if(var_817e8fd0.size) {
            goal = array::random(var_817e8fd0);
            goalpos = goal.origin;
          }
        }
      }

      if(!isDefined(goalpos)) {
        goalpos = getclosestpointonnavmesh(goalinfo.goalpos, 500, self getpathfindingradius(), self.var_6e9e073d);
      }

      self.ai.var_88b0fd29 = gettime() + randomintrange(3500, 5000);
    }

    if(isDefined(goalpos)) {
      self function_a57c34b7(goalpos, 1, 1);
      self.current_pathto_pos = goalpos;
    }

    if(self haspath()) {
      self asmrequestsubstate(#"locomotion@movement");
      result = self waittill(#"near_goal", #"stunned");
    } else {
      self asmrequestsubstate(#"hash_236f963ae1728eb3");
    }

    wait randomintrange(2, 5);
  }
}

function_37cc249f() {
  enemies = util::function_81ccf6d3(self.team);
  alltargets = arraycombine(enemies, getactorarray(), 1, 0);
  alltargets = arraysort(enemies, self.origin, 1);

  if(alltargets.size) {
    return alltargets[0];
  }

  return undefined;
}

function_d15dd929(radius, origin) {
  result = function_9cc082d2(origin + (0, 0, 100), 200);

  if(isDefined(result) && isDefined(result[#"materialflags"]) && result[#"materialflags"]&2) {
    return false;
  }

  if(!ispointonnavmesh(origin, radius, 1)) {
    return false;
  }

  return true;
}

damage_armor_activati_(entity, tacpoints) {
  validpoints = [];
  radius = entity getpathfindingradius();

  if(isDefined(tacpoints) && tacpoints.size > 0) {
    foreach(tacpoint in tacpoints) {
      if(function_d15dd929(radius, tacpoint.origin)) {
        array::add(validpoints, tacpoint);
        continue;
      }

      record3dtext("<dev string:x9e>", tacpoint.origin + (0, 0, 40), (1, 1, 1), "<dev string:x38>");

      recordline(tacpoint.origin + (0, 0, 40), tacpoint.origin, (1, 1, 1), "<dev string:x38>");

    }
  }

  return validpoints;
}

function_4ae23c85() {
  newpos = undefined;
  searchradius = 1200;
  origin = getclosestpointonnavmesh(self.origin, searchradius, self getpathfindingradius(), self.var_6e9e073d);

  if(isDefined(origin)) {
    cylinder = ai::t_cylinder(origin, searchradius, 200);
    var_8f3583cf = ai::t_cylinder(self.origin, 100, 200);
    tacpoints = tacticalquery("tank_robot_tacquery_wander", origin, cylinder, self, var_8f3583cf);
    tacpoints = damage_armor_activati_(self, tacpoints);

    if(isDefined(tacpoints) && tacpoints.size > 0) {
      tacpoints = array::randomize(tacpoints);
      newpos = getclosestpointonnavmesh(tacpoints[0].origin, self.goalradius, self getpathfindingradius(), self.var_6e9e073d);
    }
  }

  return newpos;
}

state_combat_update(params) {
  self endon(#"change_state", #"death");

  if(!isDefined(self) || !isalive(self) || iscorpse(self)) {
    return;
  }

  self setspeed(self.settings.defaultmovespeed);
  self setacceleration(isDefined(self.settings.default_move_acceleration) ? self.settings.default_move_acceleration : 10);
  heatseekingmissile::initlockfield(self);
  iterationlimit = getdvarint(#"hkai_pathfinditerationlimit", 1800);

  for(;;) {
    if(isDefined(self.isstunned) && self.isstunned || isDefined(self.var_b61a6415) && self.var_b61a6415) {
      waitframe(1);
      continue;
    }

    newpos = undefined;
    cansee = 0;

    if(isDefined(level.var_6cfbe5a)) {
      [
        [level.var_6cfbe5a]
      ] - > waitinqueue(self);
    }

    if(isDefined(self.enemy)) {
      muzzlepos = self gettagorigin("tag_flash");
      enemyeyepos = self.enemy getEye();
      cansee = sighttracepassed(muzzlepos, enemyeyepos, 0, self, self.enemy);
    }

    if(isDefined(self.enemy) && cansee) {
      var_8f3583cf = ai::t_cylinder(self.origin, 100, 200);
      tacpoints = tacticalquery("tank_robot_tacquery_combat", self.enemy.origin, self, var_8f3583cf);
      tacpoints = damage_armor_activati_(self, tacpoints);

      if(isDefined(tacpoints) && tacpoints.size > 0) {
        newpos = getclosestpointonnavmesh(tacpoints[0].origin, self.goalradius, self getpathfindingradius(), self.var_6e9e073d);
      }
    } else {
      if(isDefined(self.enemy)) {
        enemy = self.enemy;
      } else {
        enemy = self function_37cc249f();
      }

      if(isDefined(enemy)) {
        var_4e35e079 = getclosestpointonnavmesh(enemy.origin, 500, self getpathfindingradius(), self.var_6e9e073d);
        var_2a54124d = 0;

        if(isDefined(var_4e35e079)) {
          path = generatenavmeshpath(self.origin, var_4e35e079, self, undefined, undefined, iterationlimit);

          if(isDefined(path) && path.status === "succeeded") {
            var_2a54124d = 1;
          }
        }

        if(var_2a54124d) {
          newpos = var_4e35e079;
        } else {
          searchradius = 800;
          var_6dc80cbb = 100;
          origin = getclosestpointonnavmesh(self.origin, var_6dc80cbb, self.var_6e9e073d);
          forwardpos = enemy.origin;

          if(isDefined(origin)) {
            cylinder = ai::t_cylinder(origin, searchradius, 500);
            var_8f3583cf = ai::t_cylinder(self.origin, 100, 200);
            tacpoints = tacticalquery("tank_robot_tacquery_seek", origin, cylinder, self, var_8f3583cf, forwardpos);
            tacpoints = damage_armor_activati_(self, tacpoints);

            if(isDefined(tacpoints) && tacpoints.size > 0) {
              newpos = getclosestpointonnavmesh(tacpoints[0].origin, self.goalradius, self getpathfindingradius(), self.var_6e9e073d);
            }
          }
        }
      } else {
        newpos = function_4ae23c85();
      }
    }

    foundpath = 0;

    if(isDefined(newpos)) {
      self.lastgoalpos = newpos;

      if(!ispointonnavmesh(self.origin, self)) {
        getbackpoint = getclosestpointonnavmesh(self.origin, 500, self getpathfindingradius(), self.var_6e9e073d);

        if(isDefined(getbackpoint)) {
          self.origin = getbackpoint;
        }
      }

      path = generatenavmeshpath(self.origin, newpos, self, undefined, undefined, iterationlimit);

      if(isDefined(path) && path.status === "succeeded") {
        foundpath = 1;
      }

      if(foundpath) {

        recordsphere(newpos, 3, (0, 1, 0), "<dev string:x38>");

          self function_a57c34b7(newpos, 0, 1);
        self setbrake(0);
        self asmrequestsubstate(#"locomotion@movement");
        result = self waittilltimeout(randomintrange(4, 5), #"near_goal", #"stunned");
      } else {

        recordsphere(newpos, 3, (1, 0, 0), "<dev string:x38>");

      }
    }

    if(!foundpath) {
      if(isDefined(level.var_6cfbe5a)) {
        [
          [level.var_6cfbe5a]
        ] - > waitinqueue(self);
      }

      newpos = function_4ae23c85();

      if(isDefined(newpos)) {
        path = generatenavmeshpath(self.origin, newpos, self, undefined, undefined, iterationlimit);

        if(isDefined(path) && path.status === "succeeded") {
          foundpath = 1;
        }

        if(foundpath) {

          recordsphere(newpos, 3, (0, 1, 0), "<dev string:x38>");

            self function_a57c34b7(newpos, 0, 1);
          self setbrake(0);
          self asmrequestsubstate(#"locomotion@movement");
          result = self waittilltimeout(randomintrange(4, 5), #"near_goal", #"stunned");
        }
      }
    }

    if(!foundpath) {
      self function_d4c687c9();
      self setbrake(1);
      vehicle_ai::clearallmovement(1);
      self asmrequestsubstate(#"hash_236f963ae1728eb3");
      wait 1;
    }
  }
}

setup_gameplay_think(category) {
  drone = self;
  drone thread tank_abort_think();
  drone thread tank_team_kill();
  drone thread tank_too_far_from_nav_mesh_abort_think();
  drone thread tank_death_think(category);
  drone thread tank_damage_think();
  drone thread watchwater();
}

tank_team_kill() {
  if(isDefined(self.owner)) {
    self endon(#"death");
    self.owner waittill(#"teamkillkicked");
    self notify(#"death");
  }
}

kill_monitor() {
  self endon(#"death");
  last_kill_vo = 0;
  kill_vo_spacing = 4000;

  while(true) {
    waitresult = self waittill(#"killed");
    victim = waitresult.victim;

    if(!isDefined(self.owner) || !isDefined(victim)) {
      continue;
    }

    if(self.owner == victim) {
      continue;
    }

    if(level.teambased && self.owner.team == victim.team) {
      continue;
    }

    if(!self.controlled && last_kill_vo + kill_vo_spacing < gettime()) {
      self killstreaks::play_pilot_dialog_on_owner("kill", "tank_robot", self.killstreak_id);
      last_kill_vo = gettime();
    }
  }
}

tank_abort_think() {
  if(isDefined(level.var_30264985)) {
    return;
  }

  tank = self;
  tank thread killstreaks::waitfortimeout("tank_robot", 90000, &tank_timeout_callback, "death", "emp_jammed");
}

cleanup_targeting(player) {
  self notify(#"hash_3eddb5faa34443ee");

  if(isDefined(player)) {
    for(ti = 0; ti < 5; ti++) {
      if(isDefined(level.var_aca462a0[ti])) {
        uifield = level.var_aca462a0[ti];
        uifield multi_stage_target_lockon::set_targetstate(player, 0);

        if(uifield multi_stage_target_lockon::is_open(player)) {
          uifield multi_stage_target_lockon::close(player);
        }
      }

      if(isDefined(player.var_6b2d5c29) && isDefined(player.var_6b2d5c29[ti])) {
        player.var_6b2d5c29[ti].state = 0;
      }
    }
  }
}

tank_timeout_callback() {
  self killstreaks::play_pilot_dialog_on_owner("timeout", "tank_robot");
  self.timed_out = 1;
  self vehicle_death::death_fx();
  player = self.owner;

  if(isDefined(player) && isalive(player)) {
    player.ai_tank_drone = undefined;

    if(isDefined(self.controlled) && self.controlled) {
      player stop_remote();
      visionset_mgr::deactivate("visionset", "agr_visionset", player);
    }

    player clientfield::set_player_uimodel("hudItems.tankState", 0);
  }

  cleanup_targeting(player);
  wait 0.25;
  self notify(#"death");
}

tank_watch_owner_events() {
  self notify(#"tank_watch_owner_events_singleton");
  self endon(#"tank_watch_owner_events_singleton", #"death");
  res = self.owner waittill(#"joined_team", #"disconnect", #"joined_spectators");
  self makevehicleusable();

  if(isDefined(self.owner) && isDefined(self.controlled) && self.controlled) {
    visionset_mgr::deactivate("visionset", "agr_visionset", self.owner);
    self.owner stop_remote();
  }

  self.controlled = 0;

  if(isDefined(self.owner)) {
    self.owner unlink();
    self clientfield::set("vehicletransition", 0);
  }

  self makevehicleunusable();
  self.abandoned = 1;
  self notify(#"death");
}

on_end_game(drone) {
  if(isDefined(drone)) {
    drone notify(#"death");
  }
}

stop_remote() {
  if(!isDefined(self)) {
    return;
  }

  self killstreaks::clear_using_remote();
  self remote_weapons::destroyremotehud();
  self util::clientnotify("nofutz");
}

tank_hacked_health_update(hacker) {
  tank = self;
  hackeddamagetaken = tank.defaultmaxhealth - tank.hackedhealth;
  assert(hackeddamagetaken > 0);

  if(hackeddamagetaken > tank.damagetaken) {
    tank.damagetaken = hackeddamagetaken;
  }
}

tank_damage_think() {
  self endon(#"death");
  assert(isDefined(self.maxhealth));
  self.defaultmaxhealth = self.maxhealth;
  maxhealth = self.maxhealth;
  self.maxhealth = 999999;
  self.health = self.maxhealth;
  self.isstunned = 0;
  self.var_b61a6415 = 0;
  self.var_cff05bbd = 0;
  self.hackedhealthupdatecallback = &tank_hacked_health_update;
  self.hackedhealth = killstreak_bundles::get_hacked_health("tank_robot");
  low_health = 0;
  self.damagetaken = 0;

  for(;;) {
    waitresult = self waittill(#"damage");
    damage = waitresult.amount;
    attacker = waitresult.attacker;
    weapon = waitresult.weapon;
    mod = waitresult.mod;
    chargelevel = waitresult.charge_level;
    position = waitresult.position;
    flags = waitresult.flags;
    self.maxhealth = 999999;
    self.health = self.maxhealth;

    self.damage_debug = damage + "<dev string:xa6>" + weapon.name + "<dev string:xab>";

      if(weapon.isemp && mod == "MOD_GRENADE_SPLASH") {
        emp_damage_to_apply = killstreak_bundles::get_emp_grenade_damage("tank_robot", maxhealth);

        if(!isDefined(emp_damage_to_apply)) {
          emp_damage_to_apply = maxhealth / 2;
        }

        self.damagetaken += emp_damage_to_apply;
        damage = 0;

        if(!self.isstunned && emp_damage_to_apply > 0) {
          self.isstunned = 1;
          challenges::stunnedtankwithempgrenade(attacker);
          self thread tank_stun(1, 0);
        }
      }

    if(!self.isstunned) {
      if(weapon.dostun && (mod == "MOD_GRENADE_SPLASH" || mod == "MOD_GAS")) {
        self.isstunned = 1;
        self thread tank_stun(3, 0);
      }
    }

    weapon_damage = killstreak_bundles::get_weapon_damage("tank_robot", maxhealth, attacker, weapon, mod, damage, flags, chargelevel);

    if(!isDefined(weapon_damage)) {
      weapon_damage = killstreaks::get_old_damage(attacker, weapon, mod, damage, 1);
    }

    if(isDefined(level.var_30264985)) {
      weapon_damage *= 2;
    }

    self.damagetaken += weapon_damage;

    if(self.controlled && isDefined(self.owner)) {
      self.owner sendkillstreakdamageevent(int(weapon_damage));
      self.owner vehicle::update_damage_as_occupant(self.damagetaken, maxhealth);
    }

    if(self.damagetaken >= maxhealth) {
      if(isDefined(self.owner)) {
        self.owner.dofutz = 1;
      }

      self.health = 0;
      self notify(#"death", {
        #attacker: attacker, 
        #mod: mod, 
        #weapon: weapon
      });
      return;
    }

    self function_aa61ec2b(weapon_damage);

    if(!low_health && self.damagetaken > maxhealth / 1.8) {
      self killstreaks::play_pilot_dialog_on_owner("damaged", "tank_robot", self.killstreak_id);
      self thread tank_low_health_fx();
      low_health = 1;
    }
  }
}

tank_low_health_fx() {
  self endon(#"death");
  self.damage_fx = spawn("script_model", self gettagorigin("tag_origin") + (0, 0, -14));

  if(!isDefined(self.damage_fx)) {
    return;
  }

  self.damage_fx setModel(#"tag_origin");
  self.damage_fx linkto(self, "tag_turret", (0, 0, -14), (0, 0, 0));
  wait 0.1;
  playFXOnTag(level.ai_tank_damage_fx, self.damage_fx, "tag_origin");
}

function_aa61ec2b(weapon_damage) {
  if(!self.var_b61a6415) {
    self.var_cff05bbd += weapon_damage;

    if(self.var_cff05bbd >= 1000) {
      self.var_cff05bbd = 0;
      self thread tank_immobile();
    }
  }
}

tank_immobile() {
  self notify(#"immobile");
  self.var_b61a6415 = 1;
  self cancelaimove();
  self function_d4c687c9();
  controlled = self.controlled;
  owner = self.owner;

  if(controlled && isDefined(owner)) {
    owner val::set(#"tank_immobile", "freezecontrols_allowlook", 1);
  }

  self clientfield::set("ai_tank_immobile", 1);

  if(controlled && isDefined(owner)) {
    owner clientfield::set_to_player("static_postfx", 1);
  }

  self waittilltimeout(1, #"death");
  isalive = isalive(self);

  if(isalive) {
    self clientfield::set("ai_tank_immobile", 0);
    self.var_b61a6415 = 0;
  }

  if(controlled && isDefined(owner)) {
    if(!isalive || !self.isstunned) {
      owner clientfield::set_to_player("static_postfx", 0);
    }

    owner val::reset(#"tank_immobile", "freezecontrols_allowlook");
  }
}

function_903fdcc2() {
  if(isDefined(self.owner) && isDefined(self.controlled) && self.controlled) {
    visionset_mgr::deactivate("visionset", "agr_visionset", self.owner);
    self.owner stop_remote();
  }

  self.controlled = 0;

  if(isDefined(self.owner)) {
    self.owner unlink();
    self clientfield::set("vehicletransition", 0);
  }

  self makevehicleunusable();
}

function_37b0973() {
  self makevehicleusable();
}

function_4110f8dd(isjammed) {
  if(!isvehicle(self)) {
    return;
  }

  self cancelaimove();
  self function_d4c687c9();
  forward = anglesToForward(self.angles);
  forward = self.origin + forward * 128;
  forward -= (0, 0, 64);
  self turretsettarget(0, forward);
  self disablegunnerfiring(0, 1);
  self laseroff();
  controlled = self.controlled;
  owner = self.owner;
  self.isstunned = 1;

  if(controlled) {
    owner val::set(#"tank_stun", "freezecontrols", 1);
    owner.var_c4687024 = 1;
    owner sendkillstreakdamageevent(400);
  }

  self clientfield::set("stun", 1);

  if(controlled && !isjammed) {
    owner clientfield::set_to_player("static_postfx", 1);
  }

  if(controlled && isjammed) {
    owner clientfield::set_to_player("ai_tank_jam_hud", 1);
  }
}

function_fd91abfb() {
  if(!isvehicle(self)) {
    return;
  }

  isalive = isalive(self);

  if(isalive) {
    self clientfield::set("stun", 0);
    self disablegunnerfiring(0, 0);
    self.isstunned = 0;
  }

  controlled = self.controlled;
  owner = self.owner;

  if(controlled) {
    if(!isalive || !self.var_b61a6415) {
      owner clientfield::set_to_player("static_postfx", 0);
    }
  }

  if(owner.var_c4687024 === 1) {
    owner val::reset(#"tank_stun", "freezecontrols");
    owner.var_c4687024 = undefined;
  }

  owner clientfield::set_to_player("ai_tank_jam_hud", 0);
}

tank_stun(duration, isjammed) {
  self notify(#"stunned");
  self notify(#"fire_stop");
  function_4110f8dd(isjammed);
  self waittilltimeout(duration, #"death");
  function_fd91abfb();
}

emp_crazy_death() {
  self clientfield::set("stun", 1);
  self notify(#"death");
  time = 0;
  randomangle = randomint(360);

  while(time < 1.45) {
    if(isDefined(self) && validateorigin(self.origin)) {
      self turretsettarget(0, self.origin + anglesToForward((randomintrange(305, 315), int(randomangle + time * 180), 0)) * 100);

      if(time > 0.2) {
        self fireweapon(0);

        if(randomint(100) > 85) {
          rocket = self fireweapon(0);

          if(isDefined(rocket)) {
            rocket.from_ai = 1;
          }
        }
      }
    }

    time += 0.05;
    waitframe(1);
  }

  if(isDefined(self)) {
    self clientfield::set("ai_tank_death", 1);
  }

  if(isDefined(self) && isDefined(level.ai_tank_explode_fx)) {
    if(validateorigin(self.origin)) {
      playFX(level.ai_tank_explode_fx, self.origin, (0, 0, 1));
      playsoundatposition(#"exp_mantis", self.origin);
    }
  }

  waitframe(1);

  if(isDefined(self)) {
    self hide();
  }
}

function_3bb5ae4() {
  self endon(#"death");
  origin = self.origin;

  while(isDefined(self)) {
    self.origin = origin;
    waitframe(1);
  }
}

tank_death_think(hardpointname) {
  team = self.team;
  killstreak_id = self.killstreak_id;
  waitresult = self waittill(#"death");
  attacker = waitresult.attacker;
  weapon = waitresult.weapon;

  if(!isDefined(self)) {
    if(isDefined(killstreak_id)) {
      killstreak_stop_and_assert(hardpointname, team, killstreak_id, "Failed to handle death. A.");
    }

    return;
  }

  self.dead = 1;
  self laseroff();
  self function_d4c687c9();
  not_abandoned = !isDefined(self.abandoned) || !self.abandoned;

  if(isDefined(self.controlled) && self.controlled && isDefined(self.owner)) {
    self.owner sendkillstreakdamageevent(600);
    self.owner remote_weapons::destroyremotehud();
  }

  self clientfield::set("ai_tank_death", 1);
  self.isstunned = 0;
  settings = self.settings;

  if(isDefined(settings) && (self.timed_out === 1 || self.abandoned === 1)) {
    playFXOnTag(level.ai_tank_explode_fx, self, "tag_body");
    playsoundatposition(isDefined(settings.timed_out_death_sound_1) ? settings.timed_out_death_sound_1 : "exp_mantis", self.origin);
  } else {
    playFXOnTag(level.ai_tank_explode_fx, self, "tag_body");
    playsoundatposition(#"exp_mantis", self.origin);
  }

  if(isDefined(self.owner)) {
    self.owner clientfield::set_player_uimodel("hudItems.tankState", 0);
  }

  if(not_abandoned) {
    util::wait_network_frame();

    if(!isDefined(self)) {
      if(isDefined(killstreak_id)) {
        killstreak_stop_and_assert(hardpointname, team, killstreak_id, "Failed to handle death. B.");
      }

      return;
    }
  }

  if(self.controlled) {
    self ghost();

    if(validateorigin(self.origin)) {
      self thread function_3bb5ae4();
    }
  } else {
    self hide();
  }

  if(isDefined(self.damage_fx)) {
    self.damage_fx delete();
  }

  destroyedbyenemy = 0;

  if(isDefined(level.aitank_explode)) {
    destroyedbyenemy = [[level.aitank_explode]](attacker, weapon);
  }

  var_4dd90b81 = 0;

  if(isDefined(destroyedbyenemy) && destroyedbyenemy && isDefined(self.owner)) {
    var_4dd90b81 = 3;
  }

  if(isDefined(self.owner)) {
    self.owner ability_player::function_f2250880(level.var_66e94ad5, var_4dd90b81);
  }

  if(not_abandoned) {
    self waittilltimeout(2, #"remote_weapon_end", #"death");

    if(!isDefined(self)) {
      if(isDefined(killstreak_id)) {
        killstreak_stop_and_assert(hardpointname, team, killstreak_id, "Failed to handle death. C.");
      }

      return;
    }
  }

  if(isDefined(killstreak_id)) {
    killstreakrules::killstreakstop(hardpointname, team, killstreak_id);
  }

  if(isDefined(self.owner) && isalive(self.owner) && isDefined(self.controlled) && self.controlled) {
    self.owner killstreaks::switch_to_last_non_killstreak_weapon();
  }

  if(isDefined(self.aim_entity)) {
    self.aim_entity delete();
  }

  wait 1;

  if(isDefined(self)) {
    self delete();
  }
}

killstreak_stop_and_assert(hardpoint_name, team, killstreak_id, assert_msg) {
  killstreakrules::killstreakstop(hardpoint_name, team, killstreak_id);
}

tank_too_far_from_nav_mesh_abort_think() {
  self endon(#"death");
  not_on_nav_mesh_count = 0;

  for(;;) {
    wait 1;
    not_on_nav_mesh_count = isDefined(getclosestpointonnavmesh(self.origin, 480)) ? 0 : not_on_nav_mesh_count + 1;

    if(not_on_nav_mesh_count >= 4) {
      self notify(#"death");
    }
  }
}

respectnottargetedbyaitankperk(player) {
  if(!isplayer(player)) {
    return;
  }

  aitank = self;
  aitank setignoreent(player, player hasperk(#"specialty_nottargetedbyaitank"));
}

starttankremotecontrol(drone) {
  drone makevehicleusable();
  drone function_d4c687c9();
  drone turretcleartarget(0);
  drone laseroff();
  drone.treat_owner_damage_as_friendly_fire = 0;
  drone.ignore_team_kills = 0;

  if(isDefined(drone.playerdrivenversion)) {
    drone setvehicletype(drone.playerdrivenversion);
  }

  drone usevehicle(self, 0);
  drone clientfield::set("vehicletransition", 1);
  drone thread function_9868e24e(self);
  drone vehicle_ai::set_state("driving");
  drone makevehicleunusable();
  drone setbrake(0);

  if(4 != 0) {
    drone thread tank_rocket_watch(self);
  }

  drone thread vehicle::monitor_missiles_locked_on_to_me(self);

  if(!isDefined(level.var_30264985)) {
    self vehicle::set_vehicle_drivable_time(90000, drone.killstreak_end_time);
  }

  self vehicle::update_damage_as_occupant(isDefined(drone.damagetaken) ? drone.damagetaken : 0, isDefined(drone.defaultmaxhealth) ? drone.defaultmaxhealth : 100);
  drone update_client_ammo(drone.numberrockets, 1);
  self clientfield::set_player_uimodel("hudItems.tankState", 3);
  visionset_mgr::activate("visionset", "agr_visionset", self, 1, 90000, 1);

  if(isDefined(level.var_cffcf4da)) {
    self[[level.var_cffcf4da]](drone);
  }

  if(drone.isstunned === 1) {
    self val::set(#"tank_stun", "freezecontrols", 1);
    self.var_c4687024 = 1;
    self clientfield::set_to_player("ai_tank_jam_hud", 1);
  }
}

endtankremotecontrol(drone, exitrequestedbyowner) {
  not_dead = !(isDefined(drone.dead) && drone.dead);

  if(isDefined(drone.owner)) {
    drone.owner remote_weapons::destroyremotehud();
  }

  drone.treat_owner_damage_as_friendly_fire = 1;
  drone.ignore_team_kills = 1;

  if(drone.classname == "script_vehicle") {
    drone makevehicleunusable();
  }

  if(isDefined(drone.original_vehicle_type) && not_dead) {
    drone.vehicletype = drone.original_vehicle_type;
  }

  if(isDefined(drone.owner)) {
    drone.owner vehicle::stop_monitor_missiles_locked_on_to_me();
  }

  if(exitrequestedbyowner && not_dead) {
    if(isDefined(drone.settings.ai_enabled) && drone.settings.ai_enabled) {
      drone vehicle_ai::set_state("combat");
    } else {
      drone vehicle_ai::set_state("off");
    }

    if(isDefined(drone.owner)) {
      drone.owner clientfield::set_player_uimodel("hudItems.tankState", 2);
    }
  }

  if(drone.cobra === 1 && not_dead) {
    drone thread cobra_retract();
  }

  if(isDefined(drone.owner) && drone.controlled === 1) {
    visionset_mgr::deactivate("visionset", "agr_visionset", drone.owner);
  }

  drone clientfield::set("vehicletransition", 0);
  params = level.killstreakbundle[#"tank_robot"];
  shutdown_on_exit = isDefined(params.ksshutdownonexit) ? params.ksshutdownonexit : 0;

  if(shutdown_on_exit) {
    drone tank_timeout_callback();
  } else {
    drone cleanup_targeting(drone.owner);
  }

  if(isDefined(level.var_7f17a53e)) {
    drone.owner[[level.var_7f17a53e]](drone);
  }

  if(isDefined(drone) && isDefined(drone.owner)) {
    drone.owner clientfield::set_to_player("ai_tank_jam_hud", 0);
  }
}

perform_recoil_missile_turret(player) {
  bundle = level.killstreakbundle[#"tank_robot"];
  earthquake(0.4, 0.5, self.origin, 200);
  self perform_recoil("tag_barrel", isDefined(self.controlled) && self.controlled ? bundle.ksmainturretrecoilforcecontrolled : bundle.ksmainturretrecoilforce, bundle.ksmainturretrecoilforcezoffset);

  if(self.controlled && isDefined(player)) {
    player playrumbleonentity("sniper_fire");
  }
}

perform_recoil(recoil_tag, force_scale_factor, force_z_offset) {
  angles = self gettagangles(recoil_tag);
  dir = anglesToForward(angles);
  self launchvehicle(dir * force_scale_factor, self.origin + (0, 0, force_z_offset), 0);
}

update_client_ammo(ammo_count, driver_only_update = 0) {
  if(isDefined(self.owner)) {
    self.owner clientfield::set_player_uimodel("vehicle.ammoCount", ammo_count);
  }
}

watch_target(owner, target_index) {
  self endon(#"death");
  wait 3;

  if(isalive(self)) {
    level.var_aca462a0[target_index] multi_stage_target_lockon::set_targetstate(owner, 0);
    owner.var_6b2d5c29[target_index].state = 0;
  }
}

shoot_targets(projectile, max_missiles) {
  var_e3a3ecd3 = 0;
  weapon = getweapon("tank_robot_launcher_turret");
  origin = projectile.origin;
  owner = projectile.owner;
  enemies = getplayers();

  foreach(target in enemies) {
    if(isDefined(target) && isplayer(target) && util::function_fbce7263(owner.team, target.team)) {
      var_4ef4e267 = target getentitynumber();
      ti = owner.var_f1470bda[var_4ef4e267];

      if(!isDefined(ti)) {
        continue;
      }

      target_info = owner.var_6b2d5c29[ti];

      if(target_info.state == 3) {
        dir = target.origin + (0, 0, 40) - origin;
        dir = vectornormalize(dir);
        rocket = magicbullet(weapon, origin, origin + dir * 1000, owner);

        if(isDefined(rocket) && rocket.classname === "rocket") {
          rocket missile_settarget(target);
          level.var_aca462a0[ti] multi_stage_target_lockon::set_targetstate(owner, 4);
          target_info.state = 4;
          target thread watch_target(owner, ti);
          var_e3a3ecd3++;

          if(var_e3a3ecd3 >= max_missiles) {
            break;
          }
        }
      }
    }
  }

  if(var_e3a3ecd3 > 0) {
    projectile delete();
  } else {
    var_e3a3ecd3 = 1;
  }

  return var_e3a3ecd3;
}

tank_rocket_watch(player) {
  self endon(#"death");
  player endon(#"stopped_using_remote");

  if(self.numberrockets <= 0) {
    self reload_rockets(player);
  }

  if(!self.isstunned) {
    self disabledriverfiring(0);
  }

  while(true) {
    waitresult = player waittill(#"missile_fire");
    var_e3a3ecd3 = 1;

    if(isDefined(waitresult.projectile)) {
      waitresult.projectile.ignore_team_kills = self.ignore_team_kills;

      if(!(isDefined(level.var_9f011465) && level.var_9f011465)) {
        var_e3a3ecd3 = player shoot_targets(waitresult.projectile, self.numberrockets);
      }
    }

    self.numberrockets -= var_e3a3ecd3;
    self update_client_ammo(self.numberrockets);
    self perform_recoil_missile_turret(player);

    if(self.numberrockets <= 0) {
      self reload_rockets(player);
    }
  }
}

tank_rocket_watch_ai() {
  self endon(#"death");

  while(true) {
    waitresult = self waittill(#"missile_fire");

    if(isDefined(waitresult.projectile)) {
      waitresult.projectile.ignore_team_kills = self.ignore_team_kills;
      waitresult.projectile.killcament = self;
    }
  }
}

reload_rockets(player) {
  bundle = level.killstreakbundle[#"tank_robot"];
  self disabledriverfiring(1);
  weapon_wait_duration_ms = int(bundle.ksweaponreloadtime * 1000);
  player setvehicleweaponwaitduration(weapon_wait_duration_ms);
  player setvehicleweaponwaitendtime(gettime() + weapon_wait_duration_ms);
  self playsoundtoplayer(#"hash_67ccc430f6e101f3", player);
  wait bundle.ksweaponreloadtime;
  self.numberrockets = 4;
  self update_client_ammo(self.numberrockets);
  wait 0.4;

  if(!self.isstunned) {
    self disabledriverfiring(0);
  }
}

function_98a125e6() {
  var_d4b5931f = 30;
  depth = getwaterheight(self.origin) - self.origin[2];

  if(depth > var_d4b5931f) {
    return true;
  }

  return false;
}

watchwater() {
  self endon(#"death");
  var_8a7edebd = 25;
  var_29ed3475 = 12.5;
  inwater = 0;

  while(!inwater) {
    wait 0.3;
    depth = getwaterheight(self.origin) - self.origin[2];
    inwater = depth > var_8a7edebd;

    if(isDefined(self.owner) && isDefined(self.controlled) && self.controlled) {
      self.owner clientfield::set_to_player("static_postfx", depth < var_29ed3475 ? 0 : 1);
    }
  }

  if(isDefined(self.owner)) {
    self.owner.dofutz = 1;
  }

  self notify(#"death");
}

private function_3c4843e3(tank_robot, timetoadd) {
  player = self;
  tank_robot.var_7b7607df[player.clientid] = gettime() + int(timetoadd * 1000);
}