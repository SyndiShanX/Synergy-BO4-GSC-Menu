/***********************************************
 * Decompiled by ATE47 and Edited by SyndiShanX
 * Script: zm_common\zm_player.gsc
***********************************************/

#include scripts\autogenerated\luielems\initial_black;
#include scripts\core_common\ai\zombie_utility;
#include scripts\core_common\array_shared;
#include scripts\core_common\callbacks_shared;
#include scripts\core_common\clientfield_shared;
#include scripts\core_common\demo_shared;
#include scripts\core_common\drown;
#include scripts\core_common\flag_shared;
#include scripts\core_common\globallogic\globallogic_vehicle;
#include scripts\core_common\hud_util_shared;
#include scripts\core_common\killcam_shared;
#include scripts\core_common\laststand_shared;
#include scripts\core_common\lui_shared;
#include scripts\core_common\math_shared;
#include scripts\core_common\player\player_stats;
#include scripts\core_common\potm_shared;
#include scripts\core_common\scoreevents_shared;
#include scripts\core_common\status_effects\status_effects;
#include scripts\core_common\struct;
#include scripts\core_common\system_shared;
#include scripts\core_common\util_shared;
#include scripts\core_common\values_shared;
#include scripts\core_common\visionset_mgr_shared;
#include scripts\weapons\weapon_utils;
#include scripts\zm_common\bb;
#include scripts\zm_common\bots\zm_bot;
#include scripts\zm_common\gametypes\globallogic;
#include scripts\zm_common\gametypes\globallogic_player;
#include scripts\zm_common\gametypes\globallogic_scriptmover;
#include scripts\zm_common\gametypes\globallogic_spawn;
#include scripts\zm_common\gametypes\zm_gametype;
#include scripts\zm_common\util;
#include scripts\zm_common\zm;
#include scripts\zm_common\zm_armor;
#include scripts\zm_common\zm_audio;
#include scripts\zm_common\zm_bgb;
#include scripts\zm_common\zm_customgame;
#include scripts\zm_common\zm_equipment;
#include scripts\zm_common\zm_laststand;
#include scripts\zm_common\zm_loadout;
#include scripts\zm_common\zm_melee_weapon;
#include scripts\zm_common\zm_perks;
#include scripts\zm_common\zm_score;
#include scripts\zm_common\zm_stats;
#include scripts\zm_common\zm_trial;
#include scripts\zm_common\zm_utility;
#include scripts\zm_common\zm_weapons;
#include scripts\zm_common\zm_zonemgr;

#namespace zm_player;

autoexec __init__system__() {
  system::register(#"zm_player", &__init__, undefined, undefined);
}

__init__() {}

getallotherplayers() {
  aliveplayers = [];

  for(i = 0; i < level.players.size; i++) {
    if(!isDefined(level.players[i])) {
      continue;
    }

    player = level.players[i];

    if(player.sessionstate != "playing" || player == self) {
      continue;
    }

    aliveplayers[aliveplayers.size] = player;
  }

  return aliveplayers;
}

updateplayernum(player) {
  if(!isDefined(player.playernum)) {
    if(player.team == #"allies") {
      if(!isDefined(game._team1_num)) {
        game._team1_num = 0;
      }

      player.playernum = game._team1_num;
      game._team1_num = player.playernum + 1;
      return;
    }

    if(!isDefined(game._team2_num)) {
      game._team2_num = 0;
    }

    player.playernum = game._team2_num;
    game._team2_num = player.playernum + 1;
  }
}

getfreespawnpoint(spawnpoints, player) {
  if(!isDefined(spawnpoints)) {

    iprintlnbold("<dev string:x38>");

      return undefined;
  }

  if(!isDefined(game.spawns_randomized)) {
    game.spawns_randomized = 1;
    spawnpoints = array::randomize(spawnpoints);
    random_chance = randomint(100);

    if(random_chance > 50) {
      game.side_selection = 1;
    } else {
      game.side_selection = 2;
    }
  }

  side_selection = game.side_selection;

  if(game.switchedsides) {
    if(side_selection == 2) {
      side_selection = 1;
    } else if(side_selection == 1) {
      side_selection = 2;
    }
  }

  if(isDefined(player) && isDefined(player.team)) {
    for(i = 0; isDefined(spawnpoints) && i < spawnpoints.size; i++) {
      if(side_selection == 1) {
        if(player.team != #"allies" && isDefined(spawnpoints[i].script_int) && spawnpoints[i].script_int == 1) {
          arrayremovevalue(spawnpoints, spawnpoints[i]);
          i = 0;
        } else if(player.team == #"allies" && isDefined(spawnpoints[i].script_int) && spawnpoints[i].script_int == 2) {
          arrayremovevalue(spawnpoints, spawnpoints[i]);
          i = 0;
        } else {
          i++;
        }

        continue;
      }

      if(player.team == #"allies" && isDefined(spawnpoints[i].script_int) && spawnpoints[i].script_int == 1) {
        arrayremovevalue(spawnpoints, spawnpoints[i]);
        i = 0;
        continue;
      }

      if(player.team != #"allies" && isDefined(spawnpoints[i].script_int) && spawnpoints[i].script_int == 2) {
        arrayremovevalue(spawnpoints, spawnpoints[i]);
        i = 0;
        continue;
      }
    }
  }

  updateplayernum(player);

  for(j = 0; j < spawnpoints.size; j++) {
    if(!isDefined(spawnpoints[j].en_num)) {
      for(m = 0; m < spawnpoints.size; m++) {
        spawnpoints[m].en_num = m;
      }
    }

    if(spawnpoints[j].en_num == player.playernum) {
      return spawnpoints[j];
    }
  }

  return spawnpoints[0];
}

player_track_ammo_count() {
  self notify(#"stop_ammo_tracking");
  self endon(#"disconnect", #"stop_ammo_tracking");
  ammolowcount = 0;
  ammooutcount = 0;

  while(true) {
    wait 0.5;
    weapon = self getcurrentweapon();

    if(weapon == level.weaponnone || weapon.skiplowammovox) {
      continue;
    }

    if(isDefined(weapon.isheroweapon) && weapon.isheroweapon) {
      continue;
    }

    if(weapon.type == "grenade") {
      continue;
    }

    ammocount = self getammocount(weapon);
    ammoclip = self getweaponammoclip(weapon);
    ammostock = self getweaponammostock(weapon);

    if(weapon.clipsize > 3) {
      var_6814b80a = mapfloat(1, 200, 1, 0.3, weapon.clipsize);
      var_89557197 = ceil(var_6814b80a * weapon.clipsize);

      if(isDefined(level.var_142dc1b8) && isDefined(level.var_142dc1b8[weapon.name])) {
        var_89557197 = level.var_142dc1b8[weapon.name];
      } else if(ammostock < 1) {
        var_89557197 += 10;
      }

      if(ammocount > var_89557197 || self laststand::player_is_in_laststand()) {
        ammooutcount = 0;
        ammolowcount = 0;
        continue;
      }
    } else {
      var_89557197 = min(5, floor((weapon.clipsize + weapon.maxammo) / 2));

      if(ammocount > var_89557197 || self laststand::player_is_in_laststand()) {
        ammooutcount = 0;
        ammolowcount = 0;
        continue;
      }
    }

    if(ammocount > 0) {
      if(ammolowcount < 1) {
        self zm_audio::create_and_play_dialog(#"ammo", #"low");
        ammolowcount++;
      }
    } else if(ammooutcount < 1) {
      wait 0.5;

      if(self getcurrentweapon() !== weapon) {
        continue;
      }

      self zm_audio::create_and_play_dialog(#"ammo", #"out");
      ammooutcount++;
    }

    wait 20;
  }
}

spawn_vo() {
  wait 1;
  players = getplayers();

  if(players.size > 1) {
    player = array::random(players);
    index = zm_utility::get_player_index(player);
    player thread spawn_vo_player(index, players.size);
  }
}

spawn_vo_player(index, num) {
  sound = "plr_" + index + "_vox_" + num + "play";
  self playsoundwithnotify(sound, "sound_done");
  self waittill(#"sound_done");
}

precache_models() {
  if(isDefined(level.precachecustomcharacters)) {
    self[[level.precachecustomcharacters]]();
  }
}

callback_playerlaststand(einflictor, eattacker, idamage, smeansofdeath, weapon, vdir, shitloc, psoffsettime, deathanimduration) {
  self endon(#"disconnect");
  zm_laststand::playerlaststand(einflictor, eattacker, idamage, smeansofdeath, weapon, vdir, shitloc, psoffsettime, deathanimduration);
}

breakafter(time, damage, piece) {
  self notify(#"breakafter");
  self endon(#"breakafter");
  wait time;
  self dodamage(damage, self.origin, undefined, undefined);
}

function_7681dccc() {
  if(self isinvehicle()) {
    vehicle = self getvehicleoccupied();

    if(isDefined(vehicle) && isDefined(vehicle.overrideplayerdamage)) {
      return vehicle.overrideplayerdamage;
    }
  }

  if(isDefined(self.overrideplayerdamage)) {
    return self.overrideplayerdamage;
  }

  if(isDefined(level.overrideplayerdamage)) {
    return level.overrideplayerdamage;
  }
}

callback_playerdamage(einflictor, eattacker, idamage, idflags, smeansofdeath, weapon, vpoint, vdir, shitloc, vdamageorigin, psoffsettime, boneindex, vsurfacenormal) {
  if(self getinvulnerability()) {
    return;
  }

  if(isDefined(eattacker) && isplayer(eattacker) && !weapon_utils::ismeleemod(smeansofdeath)) {
    var_8f516911 = function_b576d3d(weapon, shitloc);
    idamage *= var_8f516911;
  }

  idamage = function_182d09fd(eattacker, idamage);
  startedinlaststand = 0;

  if(isplayer(self)) {
    startedinlaststand = self laststand::player_is_in_laststand();
  }

  println("<dev string:x5c>" + idamage + "<dev string:x79>");

  if(isDefined(eattacker) && isplayer(eattacker) && eattacker.sessionteam == self.sessionteam && !eattacker hasperk(#"specialty_playeriszombie") && !(isDefined(self.is_zombie) && self.is_zombie)) {
    idamage = self process_friendly_fire_callbacks(einflictor, eattacker, idamage, idflags, smeansofdeath, weapon, vpoint, vdir, shitloc, psoffsettime, boneindex);

    if(self != eattacker && !level.friendlyfire) {
      println("<dev string:x7d>");
      return;
    } else if(self == eattacker && smeansofdeath != "MOD_GRENADE_SPLASH" && smeansofdeath != "MOD_GRENADE" && smeansofdeath != "MOD_EXPLOSIVE" && smeansofdeath != "MOD_PROJECTILE" && smeansofdeath != "MOD_PROJECTILE_SPLASH" && smeansofdeath != "MOD_BURNED" && smeansofdeath != "MOD_SUICIDE" && smeansofdeath != "MOD_DOT") {
      println("<dev string:xa8>");
      return;
    }
  }

  overrideplayerdamage = function_7681dccc();

  if(isDefined(overrideplayerdamage)) {
    idamage = self[[overrideplayerdamage]](einflictor, eattacker, idamage, idflags, smeansofdeath, weapon, vpoint, vdir, shitloc, psoffsettime);
  }

  assert(isDefined(idamage), "<dev string:xcb>");

  if(isDefined(level.zm_bots_scale) && level.zm_bots_scale && isbot(self) && isDefined(einflictor) && isactor(einflictor)) {
    idamage = int(idamage / zm_bot::function_e16b5033(einflictor));
  }

  params = spawnStruct();
  params.einflictor = einflictor;
  params.eattacker = eattacker;
  params.idamage = idamage;
  params.idflags = idflags;
  params.smeansofdeath = smeansofdeath;
  params.weapon = weapon;
  params.vpoint = vpoint;
  params.vdir = vdir;
  params.shitloc = shitloc;
  params.vdamageorigin = vdamageorigin;
  params.psoffsettime = psoffsettime;
  self callback::callback(#"on_player_damage", params);

  if(isDefined(self.magic_bullet_shield) && self.magic_bullet_shield) {
    maxhealth = self.maxhealth;
    self.health += int(idamage);
    self.maxhealth = maxhealth;
  }

  if(isDefined(level.prevent_player_damage) && !level.friendlyfire) {
    if(self[[level.prevent_player_damage]](einflictor, eattacker, idamage, idflags, smeansofdeath, weapon, vpoint, vdir, shitloc, psoffsettime)) {
      return;
    }
  }

  idflags |= level.idflags_no_knockback;

  if(idamage > 0 && shitloc == "riotshield") {
    shitloc = "torso_upper";
  }

  if(isDefined(eattacker)) {
    record3dtext("<dev string:x106>" + idamage + "<dev string:x10b>" + self.health + "<dev string:x112>" + eattacker getentitynumber(), self.origin, (1, 0, 0), "<dev string:x119>", self);
  } else {
    record3dtext("<dev string:x106>" + idamage + "<dev string:x10b>" + self.health + "<dev string:x122>", self.origin, (1, 0, 0), "<dev string:x119>", self);
  }

    if(idamage > 0) {
      if(isDefined(level.var_a2d8b7eb)) {
        zm_custom::function_db030433();
        self zm_score::player_reduce_points("points_lost_on_hit_percent", level.var_a2d8b7eb);
      } else if(isDefined(level.var_39e18a71)) {
        zm_custom::function_db030433();
        self zm_score::player_reduce_points("points_lost_on_hit_value", level.var_39e18a71);

        if(zm_trial::is_trial_mode()) {
          self playsoundtoplayer(#"hash_3109126d3731f3d2", self);
        }
      }

      if(isDefined(eattacker) && eattacker.team == level.zombie_team) {
        self zm_stats::increment_player_stat("hits_taken");
        self zm_stats::forced_attachment("boas_hits_taken");
      }
    }

  idamage = int(idamage);
  self finishplayerdamagewrapper(einflictor, eattacker, idamage, idflags, smeansofdeath, weapon, vpoint, vdir, shitloc, vdamageorigin, psoffsettime, boneindex, vsurfacenormal);
  println("<dev string:x132>");
  var_ca70d16a = 0;

  if(isplayer(self)) {
    var_ca70d16a = !startedinlaststand && self laststand::player_is_in_laststand();
  }

  bb::logdamage(eattacker, self, weapon, idamage, smeansofdeath, shitloc, self.health <= 0, var_ca70d16a);

  if(isplayer(eattacker) && idamage > 0 && !(isDefined(self.var_265cb589) && self.var_265cb589) && !(isDefined(level.var_dc60105c) && level.var_dc60105c)) {
    eattacker util::show_hit_marker(var_ca70d16a);
  }
}

finishplayerdamagewrapper(einflictor, eattacker, idamage, idflags, smeansofdeath, weapon, vpoint, vdir, shitloc, vdamageorigin, psoffsettime, boneindex, vsurfacenormal) {
  self finishplayerdamage(einflictor, eattacker, idamage, idflags, smeansofdeath, weapon, vpoint, vdir, shitloc, vdamageorigin, psoffsettime, boneindex, vsurfacenormal);
}

function_182d09fd(eattacker, idamage) {
  if(!isDefined(eattacker)) {
    return int(idamage);
  }

  if(eattacker.archetype === #"zombie" && isDefined(level.var_c739ead9)) {
    idamage *= level.var_c739ead9;
  }

  if(isDefined(eattacker.archetype) && isinarray(array(#"blight_father", #"brutus", #"gegenees"), eattacker.archetype) && isDefined(level.var_1bb1a2fb)) {
    idamage *= level.var_1bb1a2fb;
  }

  if(isDefined(eattacker.archetype) && isinarray(array(#"stoker", #"gladiator", #"gladiator_marauder", #"gladiator_destroyer", #"werewolf"), eattacker.archetype) && isDefined(level.var_4d7e8b66)) {
    idamage *= level.var_4d7e8b66;
  }

  if(isDefined(eattacker.archetype) && isinarray(array(#"bat", #"dog", #"zombie_dog"), eattacker.archetype) && isDefined(level.var_5db2341c)) {
    idamage *= level.var_5db2341c;
  }

  if(isDefined(eattacker.archetype) && isinarray(array(#"nosferatu", #"skeleton", #"nova_crawler", #"tiger", #"catalyst", #"catalyst_corrosive", #"catalyst_electric", #"catalyst_plasma", #"catalyst_water"), eattacker.archetype) && isDefined(level.var_53c7ca1d)) {
    idamage *= level.var_53c7ca1d;
  }

  return int(idamage);
}

function_a8846426(callback) {
  if(!isDefined(level.player_friendly_fire_callbacks)) {
    level.player_friendly_fire_callbacks = [];
  }

  arrayremovevalue(level.player_friendly_fire_callbacks, callback);
}

register_player_friendly_fire_callback(callback) {
  if(!isDefined(level.player_friendly_fire_callbacks)) {
    level.player_friendly_fire_callbacks = [];
  }

  if(!isDefined(level.player_friendly_fire_callbacks)) {
    level.player_friendly_fire_callbacks = [];
  } else if(!isarray(level.player_friendly_fire_callbacks)) {
    level.player_friendly_fire_callbacks = array(level.player_friendly_fire_callbacks);
  }

  level.player_friendly_fire_callbacks[level.player_friendly_fire_callbacks.size] = callback;
}

process_friendly_fire_callbacks(einflictor, eattacker, idamage, idflags, smeansofdeath, weapon, vpoint, vdir, shitloc, psoffsettime, boneindex) {
  if(isDefined(level.player_friendly_fire_callbacks)) {
    foreach(callback in level.player_friendly_fire_callbacks) {
      idamage = self[[callback]](einflictor, eattacker, idamage, idflags, smeansofdeath, weapon, vpoint, vdir, shitloc, psoffsettime, boneindex);
    }
  }

  return idamage;
}

onplayerconnect_clientdvars() {
  self setclientcompass(0);
  self setclientthirdperson(0);
  self resetfov();
  self setclientthirdpersonangle(0);
  self setclientuivisibilityflag("weapon_hud_visible", 1);
  self setclientminiscoreboardhide(1);
  self setclienthudhardcore(0);
  self setclientplayerpushamount(0);
}

function_8ef51109(var_fb6fa3e1, var_bbbf9a69) {
  if(!function_3799b373(var_fb6fa3e1, var_bbbf9a69) && !zm_utility::function_91403f47()) {
    if(zm_trial::is_trial_mode()) {
      var_57807cdc = [];
      a_e_players = getplayers();

      foreach(e_player in a_e_players) {
        if(var_fb6fa3e1 === e_player) {
          continue;
        }

        array::add(var_57807cdc, e_player, 0);
      }

      if(var_57807cdc.size > 1) {
        zm_trial::fail(#"hash_61d8fe81f9fe9e9c", var_57807cdc);
      } else {
        zm_trial::fail(#"hash_272fae998263208b", var_57807cdc);
      }

      return;
    }

    level notify(#"end_game");
  }
}

function_3799b373(var_fb6fa3e1, var_bbbf9a69 = 0) {
  if(!level flag::get("start_zombie_round_logic")) {
    return true;
  }

  a_e_players = getplayers();
  var_7ff2e79a = 0;
  var_2af2f14d = 0;

  foreach(e_player in a_e_players) {
    if(!isDefined(e_player)) {
      continue;
    }

    if(var_fb6fa3e1 === e_player) {
      continue;
    }

    if(isDefined(e_player.is_zombie) && e_player.is_zombie || e_player.sessionstate === "spectator") {
      continue;
    }

    if(var_bbbf9a69 && isbot(e_player)) {
      if(!e_player laststand::player_is_in_laststand()) {
        var_7ff2e79a = 1;
      }

      continue;
    }

    if(e_player laststand::player_is_in_laststand() && e_player zm_laststand::function_618fd37e() <= 0) {
      var_2af2f14d = 1;
      continue;
    }

    return true;
  }

  if(var_bbbf9a69 && var_2af2f14d && var_7ff2e79a) {
    return true;
  }

  return false;
}

onplayerspawned() {
  self notify(#"stop_onplayerspawned");
  self endon(#"stop_onplayerspawned", #"disconnect");

  for(;;) {
    self waittill(#"spawned_player");
    self setclientuivisibilityflag("hud_visible", 1);
    self.hits = 0;
    self recordplayerrevivezombies(self);

    if(getdvarint(#"zombie_cheat", 0) >= 1 && getdvarint(#"zombie_cheat", 0) <= 3) {
      self val::set(#"zombie_devgui", "<dev string:x150>", 0);
    }

      self setactionslot(3, "altMode");
    self playerknockback(0);
    self setclientthirdperson(0);
    self resetfov();
    self setclientthirdpersonangle(0);
    self cameraactivate(0);
    self.num_perks = 0;
    self.on_lander_last_stand = undefined;
    self setblur(0, 0.1);
    self.zmbdialogqueue = [];
    self.zmbdialogactive = 0;
    self.zmbdialoggroups = [];
    self.zmbdialoggroup = "";
    self.firstspawn = 0;

    if(isDefined(level.player_out_of_playable_area_monitor) && level.player_out_of_playable_area_monitor) {
      self thread player_out_of_playable_area_monitor();
    }

    if(isDefined(level.player_too_many_players_check) && level.player_too_many_players_check) {
      level thread[[level.player_too_many_players_check_func]]();
    }

    self.var_c4890291 = [];

    if(isDefined(self.player_initialized)) {
      if(self.player_initialized == 0) {
        self.player_initialized = 1;
        self setclientuivisibilityflag("weapon_hud_visible", 1);
        self setclientminiscoreboardhide(0);

        if(!isDefined(self.is_drinking)) {
          self.is_drinking = 0;
        }

        self thread player_monitor_travel_dist();
        self thread player_monitor_time_played();

        if(getdvarint(#"hash_139191929bda93cd", 0) == 1) {
          self thread zm_breadcrumbs();
        }

        if(isDefined(level.custom_player_track_ammo_count)) {
          self thread[[level.custom_player_track_ammo_count]]();
        } else {
          self thread player_track_ammo_count();
        }

        self thread zm_utility::shock_onpain();
        self thread player_grenade_watcher();
        self laststand::revive_hud_create();

        if(isDefined(level.zm_gamemodule_spawn_func)) {
          self thread[[level.zm_gamemodule_spawn_func]]();
        }

        self thread val::set_for_time(3, #"player_spawn_protection", "ignoreme");
      }
    }

    self notify(#"perks_initialized");
  }
}

spawn_life_brush(origin, radius, height) {
  life_brush = spawn("trigger_radius", origin, 0, radius, height);
  life_brush.script_noteworthy = "life_brush";
  return life_brush;
}

in_life_brush() {
  life_brushes = getEntArray("life_brush", "script_noteworthy");

  if(!isDefined(life_brushes) || !isDefined(self)) {
    return false;
  }

  for(i = 0; i < life_brushes.size; i++) {
    if(self istouching(life_brushes[i])) {
      return true;
    }
  }

  return false;
}

spawn_kill_brush(origin, radius, height) {
  kill_brush = spawn("trigger_radius", origin, 0, radius, height);
  kill_brush.script_noteworthy = "kill_brush";
  return kill_brush;
}

in_kill_brush() {
  kill_brushes = getEntArray("kill_brush", "script_noteworthy");
  self.kill_brush = undefined;

  if(!isDefined(kill_brushes)) {
    return false;
  }

  for(i = 0; i < kill_brushes.size; i++) {
    if(self istouching(kill_brushes[i])) {
      self.kill_brush = kill_brushes[i];
      return true;
    }
  }

  return false;
}

in_enabled_playable_area(var_22a4c702 = 500) {
  if(zm_utility::function_21f4ac36()) {
    if(!isDefined(level.var_a2a9b2de)) {
      level.var_a2a9b2de = getnodearray("player_region", "script_noteworthy");
    }

    node = function_52c1730(self.origin, level.var_a2a9b2de, var_22a4c702);

    if(isDefined(node) && zm_zonemgr::zone_is_enabled(node.targetname)) {
      return true;
    }

    queryresult = function_72ce47bb(self.origin, 0, self getpathfindingradius(), self function_6a9ae71() * 0.5, 2, 1, undefined, undefined, level.var_e046d333);

    if(queryresult.data.size > 0) {
      return true;
    }
  }

  if(zm_utility::function_c85ebbbc()) {
    playable_area = getEntArray("player_volume", "script_noteworthy");

    if(!isDefined(playable_area)) {
      return false;
    }

    for(i = 0; i < playable_area.size; i++) {
      if(zm_zonemgr::zone_is_enabled(playable_area[i].targetname) && self istouching(playable_area[i])) {
        return true;
      }
    }
  }

  return false;
}

get_player_out_of_playable_area_monitor_wait_time() {

  if(isDefined(level.check_kill_thread_every_frame) && level.check_kill_thread_every_frame) {
    return 0.05;
  }

    return 3;
}

player_out_of_playable_area_monitor() {
  self notify(#"stop_player_out_of_playable_area_monitor");
  self endon(#"stop_player_out_of_playable_area_monitor", #"disconnect");
  level endon(#"end_game");

  while(!isDefined(self.characterindex)) {
    waitframe(1);
  }

  wait 0.15 * self.characterindex;

  while(true) {
    if(self.sessionstate == "spectator") {
      wait get_player_out_of_playable_area_monitor_wait_time();
      continue;
    }

    if(isDefined(self.hostmigrationcontrolsfrozen) && self.hostmigrationcontrolsfrozen) {
      wait get_player_out_of_playable_area_monitor_wait_time();
      continue;
    }

    if(self.var_f22c83f5 === 1) {
      wait get_player_out_of_playable_area_monitor_wait_time();
      continue;
    }

    if(!self in_life_brush() && (self in_kill_brush() || !self in_enabled_playable_area() || isDefined(level.player_out_of_playable_area_override) && isDefined(self[[level.player_out_of_playable_area_override]]()) && self[[level.player_out_of_playable_area_override]]())) {
      if(!isDefined(level.player_out_of_playable_area_monitor_callback) || self[[level.player_out_of_playable_area_monitor_callback]]()) {

        iprintlnbold("<dev string:x15d>" + self.origin);

        if(isDefined(level.kill_thread_test_mode) && level.kill_thread_test_mode) {
          wait get_player_out_of_playable_area_monitor_wait_time();
          continue;
        }

        if(self isinmovemode("<dev string:x176>", "<dev string:x17c>") || isDefined(level.disable_kill_thread) && level.disable_kill_thread || getdvarint(#"zombie_cheat", 0) > 0) {
          wait get_player_out_of_playable_area_monitor_wait_time();
          continue;
        }

          self zm_stats::increment_map_cheat_stat("cheat_out_of_playable");
        self zm_stats::increment_client_stat("cheat_out_of_playable", 0);
        self zm_stats::increment_client_stat("cheat_total", 0);
        self playlocalsound(#"zmb_player_outofbounds");

        if(isDefined(self.maxhealth) && self.maxhealth > 0) {
          n_damage = self.maxhealth / 3 + 1;
        } else {
          n_damage = 51;
        }

        if(self.health <= n_damage) {
          self zm_laststand::function_3d685b5f(0);
          self.var_39c78617 = 1;
        }

        self.var_dad8bef6 = 1;
        self dodamage(n_damage, self.origin);
        self.var_dad8bef6 = undefined;
      }
    }

    wait get_player_out_of_playable_area_monitor_wait_time();
  }
}

function_de3936f8(var_ffb1863c) {
  self notify(#"hash_639868d8cfc48f96");
  self endon(#"disconnect", #"hash_639868d8cfc48f96");
  self waittilltimeout(1, #"weapon_change_complete");

  if(self zm_loadout::has_powerup_weapon() || self laststand::player_is_in_laststand() || self.sessionstate == "spectator" || isDefined(self.laststandpistol)) {
    return;
  }

  var_287a8343 = zm_utility::get_player_weapon_limit(self);
  var_3ba4bf7d = self getweaponslistprimaries();

  if(var_3ba4bf7d.size > var_287a8343) {
    self zm_melee_weapon::take_fallback_weapon();
    var_3ba4bf7d = self getweaponslistprimaries();

    if(var_3ba4bf7d.size > var_287a8343) {
      self zm_stats::increment_map_cheat_stat("cheat_too_many_weapons");
      self zm_stats::increment_client_stat("cheat_too_many_weapons", 0);
      self zm_stats::increment_client_stat("cheat_total", 0);
      self playlocalsound(level.zmb_laugh_alias);

      if(isDefined(var_ffb1863c) && self hasweapon(var_ffb1863c) && isinarray(var_3ba4bf7d, var_ffb1863c)) {
        self takeweapon(var_ffb1863c);
      } else if(isinarray(var_3ba4bf7d, self.currentweapon)) {
        self takeweapon(self.currentweapon);
      } else {
        self takeweapon(var_3ba4bf7d[0]);
      }

      wait 1;

      if(!self getweaponslistprimaries().size) {
        self zm_loadout::give_start_weapon(1);
      }
    }
  }
}

player_monitor_travel_dist() {
  self notify(#"stop_player_monitor_travel_dist");
  self endon(#"stop_player_monitor_travel_dist", #"disconnect");
  n_current_distance = 0;

  for(prevpos = self.origin; isDefined(self); prevpos = self.origin) {
    wait 0.1;

    if(self.var_16735873 !== 1) {
      n_distance = distance(self.origin, prevpos);
      self.pers[#"distance_traveled"] += n_distance;

      if(n_distance > 1 && int(self.pers[#"distance_traveled"]) > n_current_distance) {
        self zm_stats::function_301c4be2("boas_distanceSprinted", int(n_distance));
        n_current_distance = self.pers[#"distance_traveled"];
      }
    }
  }
}

player_monitor_time_played() {
  self notify(#"stop_player_monitor_time_played");
  self endon(#"stop_player_monitor_time_played", #"disconnect");
  level flag::wait_till("start_zombie_round_logic");

  for(;;) {
    wait 1;
    zm_stats::increment_client_stat("time_played_total");
  }
}

zm_breadcrumbs() {
  self endon(#"disconnect");
  level endon(#"end_game");
  waittime = getdvarfloat(#"hash_46009edd5032b8cc", 2);
  level flag::wait_till("start_zombie_round_logic");

  while(true) {
    if(isalive(self)) {
      recordbreadcrumbdataforplayer(self);
    }

    wait waittime;
  }
}

player_grenade_multiattack_bookmark_watcher(grenade, weapon) {
  self endon(#"disconnect");
  waittillframeend();

  if(!isDefined(grenade)) {
    return;
  }

  inflictorentnum = grenade getentitynumber();
  inflictorenttype = grenade getentitytype();
  inflictorbirthtime = 0;

  if(isDefined(grenade.birthtime)) {
    inflictorbirthtime = grenade.birthtime;
  }

  killcam_entity_info = killcam::get_killcam_entity_info(self, grenade, weapon);
  einflictor = grenade;
  ret_val = grenade waittilltimeout(15, #"explode", #"death", #"disconnect");

  if(!isDefined(self) || isDefined(ret_val) && "timeout" == ret_val._notify) {
    return;
  }

  self.grenade_multiattack_count = 0;
  self.grenade_multiattack_ent = undefined;
  self.grenade_multikill_count = 0;
  waittillframeend();

  if(!isDefined(self)) {
    return;
  }

  count = level.grenade_multiattack_bookmark_count;

  if(isDefined(grenade.grenade_multiattack_bookmark_count) && grenade.grenade_multiattack_bookmark_count) {
    count = grenade.grenade_multiattack_bookmark_count;
  }

  var_7b841aa9 = #"zm_player_grenade_multiattack";

  if(isDefined(grenade.use_grenade_special_long_bookmark) && grenade.use_grenade_special_long_bookmark) {
    var_7b841aa9 = #"zm_player_grenade_special_long";
  } else if(isDefined(grenade.use_grenade_special_bookmark) && grenade.use_grenade_special_bookmark) {
    var_7b841aa9 = #"zm_player_grenade_special_long";
  }

  if(count <= self.grenade_multiattack_count && isDefined(self.grenade_multiattack_ent)) {
    deathtime = gettime();
    perks = [];
    killstreaks = [];
    demo::bookmark(var_7b841aa9, gettime(), self, undefined, 0);
    potm::bookmark(var_7b841aa9, gettime(), self, undefined, 0);
    potm::function_5523a49a(var_7b841aa9, self getentitynumber(), self getxuid(), self.grenade_multiattack_ent, killcam_entity_info, weapon, "MOD_GRENADE", deathtime, 0, 0, perks, killstreaks, self, einflictor);
  }

  if(5 <= self.grenade_multikill_count) {
    self zm_stats::increment_challenge_stat(#"zombie_hunter_explosion_multikill");
  }

  self.grenade_multiattack_count = 0;
  self.grenade_multikill_count = 0;
}

player_grenade_watcher() {
  self notify(#"stop_player_grenade_watcher");
  self endon(#"stop_player_grenade_watcher", #"disconnect");
  self.grenade_multiattack_count = 0;
  self.grenade_multikill_count = 0;

  while(true) {
    waitresult = self waittill(#"grenade_fire");
    grenade = waitresult.projectile;
    weapon = waitresult.weapon;

    if(isDefined(grenade) && isalive(grenade)) {
      grenade.team = self.team;
    }

    self thread player_grenade_multiattack_bookmark_watcher(grenade, weapon);

    if(isDefined(level.grenade_watcher)) {
      self[[level.grenade_watcher]](grenade, weapon);
    }
  }
}

player_prevent_damage(einflictor, eattacker, idamage, idflags, smeansofdeath, weapon, vpoint, vdir, shitloc, psoffsettime) {
  if(isai(eattacker) && self.ignoreme && smeansofdeath === "MOD_MELEE") {
    return true;
  }

  if(isai(eattacker) && self.ignoreme) {
    println("<dev string:x185>" + function_9e72a96(eattacker.archetype) + "<dev string:x1be>" + smeansofdeath);
  }

  if(isDefined(self.bgb_in_plain_sight_active) && self.bgb_in_plain_sight_active) {
    str = "<dev string:x1c7>";

    if(isai(eattacker)) {
      str += function_9e72a96(eattacker.archetype);
    } else if(isDefined(eattacker)) {
      str = str + "<dev string:x1f6>" + eattacker getentitynumber();
    } else {
      str += "<dev string:x200>";
    }

    println(str);
    println("<dev string:x218>" + (isDefined(self.ignoreme) && self.ignoreme ? "<dev string:x22f>" : "<dev string:x236>"));
    println("<dev string:x23e>" + smeansofdeath);
    println("<dev string:x252>" + idamage + "<dev string:x259>");
  }

    if(!isDefined(einflictor) || !isDefined(eattacker)) {
      return false;
    }

  if(einflictor == self || eattacker == self) {
    return false;
  }

  if(isDefined(einflictor) && isDefined(einflictor.team)) {
    if(!(isDefined(einflictor.damage_own_team) && einflictor.damage_own_team)) {
      if(einflictor.team == self.team) {
        return true;
      }
    }
  }

  return false;
}

player_revive_monitor() {
  self notify(#"stop_player_revive_monitor");
  self endon(#"stop_player_revive_monitor", #"disconnect");

  while(true) {
    waitresult = self waittill(#"player_revived");
    reviver = waitresult.reviver;
    self playSound(#"zmb_character_revived");

    if(isDefined(level.isresetting_grief) && level.isresetting_grief) {
      continue;
    }

    if(isDefined(reviver)) {
      if(reviver != self) {
        if(math::cointoss()) {
          self zm_audio::create_and_play_dialog(#"revive", #"up");
        } else {
          reviver zm_audio::create_and_play_dialog(#"revive", #"support");
        }
      } else {
        self zm_audio::create_and_play_dialog(#"revive", #"up");
      }

      points = self.score_lost_when_downed;

      if(!isDefined(points) || self == reviver || zm_custom::function_901b751c(#"zmpointlossondown")) {
        points = 0;
      } else if(points > 2500) {
        points = 2500 + (points - 2500) * 0.5;
      }

      println("<dev string:x263>" + points);
      reviver zm_score::player_add_points("reviver", points);
      self.score_lost_when_downed = 0;

      if(isplayer(reviver) && reviver != self) {
        reviver zm_stats::increment_challenge_stat(#"survivalist_revive", undefined, 1);
        reviver zm_stats::increment_challenge_stat(#"hash_79ba5b62b95a7eb6", undefined, 1);
        reviver zm_stats::function_c0c6ab19(#"revives", 1, 1);
      }
    }
  }
}

spawnspectator() {
  self endon(#"disconnect", #"spawned_spectator");
  self notify(#"spawned");
  self notify(#"end_respawn");

  if(level.intermission) {
    return;
  }

  if(isDefined(level.no_spectator) && level.no_spectator) {
    wait 3;
    exitlevel();
  }

  self.is_zombie = 1;
  self notify(#"zombified");

  if(isDefined(self.revivetrigger)) {
    self.revivetrigger delete();
    self.revivetrigger = undefined;
  }

  self.zombification_time = gettime();
  resettimeout();
  self stopshellshock();
  self stoprumble("damage_heavy");
  self.sessionstate = "spectator";
  self.spectatorclient = -1;
  self.maxhealth = self.health;
  self.shellshocked = 0;
  self.inwater = 0;
  self.friendlydamage = undefined;
  self.hasspawned = 1;
  self.spawntime = gettime();
  self.afk = 0;
  println("<dev string:x282>");
  self detachall();

  if(isDefined(level.var_7abfc4ea)) {
    self[[level.var_7abfc4ea]]();
  } else {
    self setspectatepermissions(1);
  }

  self spawn(self.origin, self.angles);
  self notify(#"spawned_spectator");
}

setspectatepermissions(ison) {
  self allowspectateteam(#"allies", ison && self.team == #"allies");
  self allowspectateteam(#"axis", ison && self.team == #"axis");
  self allowspectateteam("freelook", 0);
  self allowspectateteam("none", 0);
}

spectator_toggle_3rd_person() {
  self endon(#"disconnect", #"spawned_player");
  self set_third_person(1);
}

set_third_person(value) {
  if(value) {
    self setclientthirdperson(1);
    self setclientthirdpersonangle(354);
  } else {
    self setclientthirdperson(0);
    self setclientthirdpersonangle(0);
  }

  self resetfov();
}

last_stand_revive() {
  level endon(#"between_round_over");
  players = getplayers();
  laststand_count = 0;

  foreach(player in players) {
    if(!zm_utility::is_player_valid(player)) {
      laststand_count++;
    }
  }

  if(laststand_count == players.size) {
    for(i = 0; i < players.size; i++) {
      if(players[i] laststand::player_is_in_laststand() && players[i].revivetrigger.beingrevived == 0) {
        players[i] zm_laststand::auto_revive(players[i]);
      }
    }
  }
}

spectators_respawn() {
  level endon(#"between_round_over", #"end_game");

  if(!isDefined(zombie_utility::get_zombie_var(#"spectators_respawn")) || !zombie_utility::get_zombie_var(#"spectators_respawn")) {
    return;
  }

  while(true) {
    players = getplayers();

    for(i = 0; i < players.size; i++) {
      e_player = players[i];
      e_player spectator_respawn_player();
    }

    wait 1;
  }
}

spectator_respawn_player() {
  if(self.sessionstate == "spectator" && isDefined(self.spectator_respawn)) {
    if(!isDefined(level.custom_spawnplayer)) {
      level.custom_spawnplayer = &spectator_respawn;
    }

    self[[level.spawnplayer]]();

    if(isDefined(level.script) && level.round_number > 6 && self.score < 1500) {
      self.old_score = self.score;

      if(isDefined(level.var_cf66a6f6)) {
        self[[level.var_cf66a6f6]]();
      }

      self.score = 1500;
    }

    if(isDefined(level.var_857878e6)) {
      self[[level.var_857878e6]]();
    }
  }
}

spectator_respawn() {
  println("<dev string:x2b1>");
  assert(isDefined(self.spectator_respawn));

  if(!isDefined(self) || !isDefined(self.spectator_respawn)) {
    return;
  }

  origin = self.spectator_respawn.origin;
  angles = self.spectator_respawn.angles;
  self setspectatepermissions(0);
  new_origin = undefined;

  if(isDefined(level.var_5816975b)) {
    new_origin = [[level.var_5816975b]](self);
  }

  if(!isDefined(new_origin)) {
    new_origin = check_for_valid_spawn_near_team(self, 1);
  }

  if(isDefined(new_origin)) {
    if(!isDefined(new_origin.angles)) {
      angles = (0, 0, 0);
    } else {
      angles = new_origin.angles;
    }

    self spawn(new_origin.origin, angles);
  } else {
    self spawn(origin, angles);
  }

  if(isDefined(self zm_loadout::get_player_placeable_mine())) {
    self takeweapon(self zm_loadout::get_player_placeable_mine());
    self zm_loadout::set_player_placeable_mine(level.weaponnone);
  }

  self zm_equipment::take();
  self.is_burning = undefined;
  self.abilities = [];
  self.is_zombie = 0;
  val::reset(#"laststand", "ignoreme");
  self clientfield::set("zmbLastStand", 0);
  self reviveplayer();

  if(isDefined(level._zombiemode_post_respawn_callback)) {
    self thread[[level._zombiemode_post_respawn_callback]]();
  }

  self zm_score::player_reduce_points("died");
  self zm_melee_weapon::spectator_respawn_all();
  self thread zm_perks::function_2babacc2();
  return 1;
}

check_for_valid_spawn_near_team(revivee, return_struct) {
  if(isDefined(level.check_for_valid_spawn_near_team_callback)) {
    spawn_location = [[level.check_for_valid_spawn_near_team_callback]](revivee, return_struct);
    return spawn_location;
  }

  players = getplayers();
  spawn_points = zm_gametype::get_player_spawns_for_gametype();
  closest_group = undefined;
  closest_distance = 100000000;
  backup_group = undefined;
  backup_distance = 100000000;

  if(spawn_points.size == 0) {
    return undefined;
  }

  a_enabled_zone_entities = zm_zonemgr::get_active_zones_entities();

  for(i = 0; i < players.size; i++) {
    if(zm_utility::is_player_valid(players[i], undefined, 1) && (players[i] != self || players.size == 1)) {
      for(j = 0; j < spawn_points.size; j++) {
        if(isDefined(spawn_points[j].script_int)) {
          ideal_distance = spawn_points[j].script_int;
        } else {
          ideal_distance = 1000;
        }

        if(zm_utility::check_point_in_enabled_zone(spawn_points[j].origin, 1, a_enabled_zone_entities) == 0) {
          continue;
        }

        if(spawn_points[j].locked == 0) {
          plyr_dist = distancesquared(players[i].origin, spawn_points[j].origin);

          if(plyr_dist < ideal_distance * ideal_distance) {
            if(plyr_dist < closest_distance) {
              closest_distance = plyr_dist;
              closest_group = j;
            }

            continue;
          }

          if(plyr_dist < backup_distance) {
            backup_group = j;
            backup_distance = plyr_dist;
          }
        }
      }
    }

    if(!isDefined(closest_group)) {
      closest_group = backup_group;
    }

    if(isDefined(closest_group)) {
      spawn_location = get_valid_spawn_location(revivee, spawn_points, closest_group, return_struct);

      if(isDefined(spawn_location)) {
        return spawn_location;
      }
    }
  }

  return undefined;
}

get_valid_spawn_location(revivee, spawn_points, closest_group, return_struct) {
  spawn_array = struct::get_array(spawn_points[closest_group].target, "targetname");

  if(level flag::get("round_reset")) {
    spawn_point_index = revivee getentitynumber();
    assert(spawn_point_index >= 0 && spawn_point_index < spawn_array.size);

    if(isDefined(return_struct) && return_struct) {
      return spawn_array[spawn_point_index];
    } else {
      return spawn_array[spawn_point_index].origin;
    }
  }

  spawn_array = array::randomize(spawn_array);

  for(k = 0; k < spawn_array.size; k++) {
    if(isDefined(spawn_array[k].plyr) && spawn_array[k].plyr == revivee getentitynumber()) {
      if(positionwouldtelefrag(spawn_array[k].origin)) {
        spawn_array[k].plyr = undefined;
        break;
      }

      if(isDefined(return_struct) && return_struct) {
        return spawn_array[k];
      }

      return spawn_array[k].origin;
    }
  }

  for(k = 0; k < spawn_array.size; k++) {
    if(positionwouldtelefrag(spawn_array[k].origin)) {
      continue;
    }

    if(!isDefined(spawn_array[k].plyr) || spawn_array[k].plyr == revivee getentitynumber()) {
      spawn_array[k].plyr = revivee getentitynumber();

      if(isDefined(return_struct) && return_struct) {
        return spawn_array[k];
      }

      return spawn_array[k].origin;
    }
  }

  if(isDefined(return_struct) && return_struct) {
    return spawn_array[0];
  }

  return spawn_array[0].origin;
}

check_for_valid_spawn_near_position(revivee, v_position, return_struct) {
  spawn_points = zm_gametype::get_player_spawns_for_gametype();

  if(spawn_points.size == 0) {
    return undefined;
  }

  closest_group = undefined;
  closest_distance = 100000000;
  backup_group = undefined;
  backup_distance = 100000000;

  for(i = 0; i < spawn_points.size; i++) {
    if(isDefined(spawn_points[i].script_int)) {
      ideal_distance = spawn_points[i].script_int;
    } else {
      ideal_distance = 1000;
    }

    if(spawn_points[i].locked == 0) {
      dist = distancesquared(v_position, spawn_points[i].origin);

      if(dist < ideal_distance * ideal_distance) {
        if(dist < closest_distance) {
          closest_distance = dist;
          closest_group = i;
        }
      } else if(dist < backup_distance) {
        backup_group = i;
        backup_distance = dist;
      }
    }

    if(!isDefined(closest_group)) {
      closest_group = backup_group;
    }
  }

  if(isDefined(closest_group)) {
    spawn_location = get_valid_spawn_location(revivee, spawn_points, closest_group, return_struct);

    if(isDefined(spawn_location)) {
      return spawn_location;
    }
  }

  return undefined;
}

check_for_valid_spawn_within_range(revivee, v_position, return_struct, min_distance, max_distance) {
  spawn_points = zm_gametype::get_player_spawns_for_gametype();

  if(spawn_points.size == 0) {
    return undefined;
  }

  closest_group = undefined;
  closest_distance = 100000000;

  for(i = 0; i < spawn_points.size; i++) {
    if(spawn_points[i].locked == 0) {
      dist = distance(v_position, spawn_points[i].origin);

      if(dist >= min_distance && dist <= max_distance) {
        if(dist < closest_distance) {
          closest_distance = dist;
          closest_group = i;
        }
      }
    }
  }

  if(isDefined(closest_group)) {
    spawn_location = get_valid_spawn_location(revivee, spawn_points, closest_group, return_struct);

    if(isDefined(spawn_location)) {
      return spawn_location;
    }
  }

  return undefined;
}

get_players_on_team(exclude) {
  teammates = [];
  players = getplayers();

  for(i = 0; i < players.size; i++) {
    if(players[i].spawn_side == self.spawn_side && !isDefined(players[i].revivetrigger) && players[i] != exclude) {
      teammates[teammates.size] = players[i];
    }
  }

  return teammates;
}

get_safe_breadcrumb_pos(player) {
  players = getplayers();
  valid_players = [];

  for(i = 0; i < players.size; i++) {
    if(!zm_utility::is_player_valid(players[i])) {
      continue;
    }

    valid_players[valid_players.size] = players[i];
  }

  for(i = 0; i < valid_players.size; i++) {
    count = 0;

    for(q = 1; q < player.zombie_breadcrumbs.size; q++) {
      if(distancesquared(player.zombie_breadcrumbs[q], valid_players[i].origin) < 22500) {
        continue;
      }

      count++;

      if(count == valid_players.size) {
        return player.zombie_breadcrumbs[q];
      }
    }
  }

  return undefined;
}

play_door_dialog() {
  self endon(#"warning_dialog");
  timer = 0;

  while(true) {
    waitframe(1);
    players = getplayers();

    for(i = 0; i < players.size; i++) {
      dist = distancesquared(players[i].origin, self.origin);

      if(dist > 4900) {
        timer = 0;
        continue;
      }

      while(dist < 4900 && timer < 3) {
        wait 0.5;
        timer++;
      }

      if(dist > 4900 && timer >= 3) {
        self playSound(#"door_deny");
        players[i] zm_audio::create_and_play_dialog(#"general", #"outofmoney");
        wait 3;
        self notify(#"warning_dialog");
      }
    }
  }
}

remove_ignore_attacker() {
  self notify(#"new_ignore_attacker");
  self endon(#"new_ignore_attacker", #"disconnect");

  if(!isDefined(level.ignore_enemy_timer)) {
    level.ignore_enemy_timer = 0.4;
  }

  wait level.ignore_enemy_timer;
  self.ignoreattacker = undefined;
}

player_damage_override_cheat(einflictor, eattacker, idamage, idflags, smeansofdeath, weapon, vpoint, vdir, shitloc, psoffsettime) {
  player_damage_override(einflictor, eattacker, idamage, idflags, smeansofdeath, weapon, vpoint, vdir, shitloc, psoffsettime);
  return false;
}

player_damage_override(einflictor, eattacker, idamage, idflags, smeansofdeath, weapon, vpoint, vdir, shitloc, psoffsettime) {
  idamage = self check_player_damage_callbacks(einflictor, eattacker, idamage, idflags, smeansofdeath, weapon, vpoint, vdir, shitloc, psoffsettime);

  if(self.scene_takedamage === 0) {
    return 0;
  }

  if(isDefined(level.prevent_player_damage) && !level.friendlyfire) {
    if(self[[level.prevent_player_damage]](einflictor, eattacker, idamage, idflags, smeansofdeath, weapon, vpoint, vdir, shitloc, psoffsettime)) {
      return 0;
    }
  }

  if(isDefined(eattacker) && isDefined(eattacker.b_aat_fire_works_weapon) && eattacker.b_aat_fire_works_weapon) {
    return 0;
  }

  if(isDefined(self.use_adjusted_grenade_damage) && self.use_adjusted_grenade_damage) {
    self.use_adjusted_grenade_damage = undefined;

    if(self.health > idamage) {
      return idamage;
    }
  }

  if(!idamage) {
    return 0;
  }

  if(self laststand::player_is_in_laststand()) {
    return 0;
  }

  if(isDefined(einflictor)) {
    if(isDefined(einflictor.water_damage) && einflictor.water_damage) {
      return 0;
    }
  }

  if(isDefined(eattacker)) {
    if(eattacker.owner === self) {
      return 0;
    }

    if(isDefined(self.ignoreattacker) && self.ignoreattacker == eattacker) {
      return 0;
    }

    if(isDefined(self.is_zombie) && self.is_zombie && isDefined(eattacker.is_zombie) && eattacker.is_zombie) {
      return 0;
    }

    if(isDefined(eattacker.is_zombie) && eattacker.is_zombie) {
      self.ignoreattacker = eattacker;
      self thread remove_ignore_attacker();

      if(isDefined(eattacker.custom_damage_func)) {
        idamage = eattacker[[eattacker.custom_damage_func]](self);
      }
    }

    eattacker notify(#"hit_player");

    if(isDefined(eattacker) && isDefined(eattacker.func_mod_damage_override)) {
      smeansofdeath = eattacker[[eattacker.func_mod_damage_override]](einflictor, smeansofdeath, weapon);
    }

    if(smeansofdeath != "MOD_FALLING") {
      if(isDefined(eattacker.is_zombie) && eattacker.is_zombie || isplayer(eattacker)) {
        self playrumbleonentity("damage_heavy");
      }

      if(eattacker.archetype === #"zombie") {
        self zm_audio::create_and_play_dialog(#"general", #"attacked");
      }

      if(randomintrange(0, 1) == 0) {
        self thread zm_audio::playerexert("hitmed");
      } else {
        self thread zm_audio::playerexert("hitlrg");
      }
    }
  }

  if(isDefined(smeansofdeath) && smeansofdeath == "MOD_DROWN") {
    self thread zm_audio::playerexert("drowning", 1);
    self.voxdrowning = 1;
  }

  if(isDefined(level.perk_damage_override)) {
    foreach(func in level.perk_damage_override) {
      n_damage = self[[func]](einflictor, eattacker, idamage, idflags, smeansofdeath, weapon, vpoint, vdir, shitloc, psoffsettime);

      if(isDefined(n_damage)) {
        idamage = n_damage;
      }
    }
  }

  if(zm_loadout::is_placeable_mine(weapon)) {
    return 0;
  }

  if(isDefined(self.player_damage_override)) {
    self thread[[self.player_damage_override]](einflictor, eattacker, idamage, idflags, smeansofdeath, weapon, vpoint, vdir, shitloc, psoffsettime);
  }

  if(isDefined(einflictor) && isDefined(einflictor.archetype) && einflictor.archetype == #"zombie_quad") {
    if(smeansofdeath == "MOD_EXPLOSIVE") {
      if(self.health > 75) {
        return 75;
      }
    }
  }

  if(smeansofdeath == "MOD_SUICIDE" && self bgb::is_enabled(#"zm_bgb_danger_closest")) {
    return 0;
  }

  if(zm_utility::is_explosive_damage(smeansofdeath)) {
    if(self bgb::is_enabled(#"zm_bgb_danger_closest")) {
      return 0;
    }

    if(!(isDefined(self.is_zombie) && self.is_zombie)) {
      if(!isDefined(eattacker) || !(isDefined(eattacker.is_zombie) && eattacker.is_zombie) && !(isDefined(eattacker.b_override_explosive_damage_cap) && eattacker.b_override_explosive_damage_cap)) {
        if(isDefined(weapon.name) && (weapon.name == #"ray_gun" || weapon.name == #"ray_gun_upgraded")) {
          if(self.health > 25 && idamage > 25) {
            return 25;
          }
        } else if(self.health > 75 && idamage > 75) {
          return 75;
        }
      }
    }
  }

  idamage = self zm_armor::damage(idamage, smeansofdeath, eattacker);

  if(isDefined(level.var_ccdc4ca6)) {
    for(i = 0; i < level.var_ccdc4ca6.size; i++) {
      var_36da0ddb = self[[level.var_ccdc4ca6[i]]](einflictor, eattacker, idamage, idflags, smeansofdeath, weapon, vpoint, vdir, shitloc, psoffsettime);

      if(isDefined(var_36da0ddb) && var_36da0ddb != -1) {
        idamage = var_36da0ddb;
      }
    }
  }

  finaldamage = idamage;

  if(idamage < self.health) {
    if(isDefined(eattacker)) {
      if(isDefined(level.custom_kill_damaged_vo)) {
        eattacker thread[[level.custom_kill_damaged_vo]](self);
      } else {
        eattacker.sound_damage_player = self;
      }

      if(isDefined(eattacker.missinglegs) && eattacker.missinglegs) {
        self zm_audio::create_and_play_dialog(#"general", #"crawl_hit");
      }
    }

    return idamage;
  }

  if(isDefined(level.player_death_override) && self[[level.player_death_override]]()) {
    return 0;
  }

  if(isDefined(eattacker)) {
    self zm_stats::handle_death(einflictor, eattacker, weapon, smeansofdeath);
  }

  self thread clear_path_timers();

  if(level.intermission) {
    level waittill(#"forever");
  }

  if(level.scr_zm_ui_gametype == "zcleansed" && idamage > 0) {
    if(isDefined(eattacker) && isplayer(eattacker) && eattacker.team != self.team && (!(isDefined(self.laststand) && self.laststand) && !self laststand::player_is_in_laststand() || !isDefined(self.last_player_attacker))) {
      if(isDefined(eattacker.maxhealth) && isDefined(eattacker.is_zombie) && eattacker.is_zombie) {
        eattacker.health = eattacker.maxhealth;
      }

      if(isDefined(level.player_kills_player)) {
        self thread[[level.player_kills_player]](einflictor, eattacker, idamage, idflags, smeansofdeath, weapon, vpoint, vdir, shitloc, psoffsettime);
      }
    }
  }

  if(self hasperk(#"specialty_whoswho") && self zm_laststand::function_618fd37e() > 0) {
    self zm_laststand::function_409dc98e();

    if(isDefined(level.whoswho_laststand_func)) {
      self thread[[level.whoswho_laststand_func]]();
      return 0;
    }
  }

  if(self zm_laststand::function_618fd37e() > 0) {
    var_228d944 = 1;
  } else {
    var_228d944 = function_3799b373(self);
  }

  if(var_228d944 || zm_utility::function_91403f47()) {
    return finaldamage;
  }

  if(isDefined(level.var_57cc29f3) && [[level.var_57cc29f3]](self)) {
    return finaldamage;
  }

  if(getplayers().size == 1 && level flag::get("solo_game")) {
    if(isDefined(level.var_fb697fca) && [
        [level.var_fb697fca]
      ]()) {
      return finaldamage;
    } else {
      self.intermission = 1;
    }
  }

  level notify(#"stop_suicide_trigger");
  self allowprone(1);
  self thread zm_laststand::playerlaststand(einflictor, eattacker, idamage, smeansofdeath, weapon, vdir, shitloc, psoffsettime);

  if(!isDefined(vdir)) {
    vdir = (1, 0, 0);
  }

  self fakedamagefrom(vdir);
  level notify(#"last_player_died");

  if(isDefined(level.custom_player_fake_death)) {
    self thread[[level.custom_player_fake_death]](vdir, smeansofdeath);
  } else {
    self thread player_fake_death();
  }

  level notify(#"pre_end_game");
  util::wait_network_frame();

  if(level flag::get("dog_round")) {
    zm::increment_dog_round_stat("lost");
  }

  level notify(#"end_game");
  return 0;
}

clear_path_timers() {
  zombies = getaiteamarray(level.zombie_team);

  foreach(zombie in zombies) {
    if(isDefined(zombie.favoriteenemy) && zombie.favoriteenemy == self) {
      zombie.zombie_path_timer = 0;
    }
  }
}

check_player_damage_callbacks(einflictor, eattacker, idamage, idflags, smeansofdeath, weapon, vpoint, vdir, shitloc, psoffsettime) {
  if(isDefined(level.var_5391c404)) {
    for(i = 0; i < level.var_5391c404.size; i++) {
      newdamage = self[[level.var_5391c404[i]]](einflictor, eattacker, idamage, idflags, smeansofdeath, weapon, vpoint, vdir, shitloc, psoffsettime);

      if(-1 != newdamage) {
        return newdamage;
      }
    }
  }

  if(isDefined(level.player_damage_callbacks)) {
    for(i = 0; i < level.player_damage_callbacks.size; i++) {
      newdamage = self[[level.player_damage_callbacks[i]]](einflictor, eattacker, idamage, idflags, smeansofdeath, weapon, vpoint, vdir, shitloc, psoffsettime);

      if(-1 != newdamage) {
        return newdamage;
      }
    }
  }

  return idamage;
}

function_57301eaf(func) {
  if(!isDefined(level.var_5391c404)) {
    level.var_5391c404 = [];
  }

  level.var_5391c404[level.var_5391c404.size] = func;
}

register_player_damage_callback(func) {
  if(!isDefined(level.player_damage_callbacks)) {
    level.player_damage_callbacks = [];
  }

  level.player_damage_callbacks[level.player_damage_callbacks.size] = func;
}

function_a827358a(func) {
  if(!isDefined(level.var_ccdc4ca6)) {
    level.var_ccdc4ca6 = [];
  }

  level.var_ccdc4ca6[level.var_ccdc4ca6.size] = func;
}

player_fake_death() {
  self endon(#"death");
  level notify(#"fake_death");
  self notify(#"fake_death");
  self takeallweapons();
  self allowstand(0);
  self allowcrouch(0);
  self allowprone(1);
  self allowsprint(0);
  self setstance("prone");
  self val::set(#"fake_death", "ignoreme", 1);
  self val::set(#"fake_death", "takedamage", 0);
  wait 1;
  self val::set(#"fake_death", "freezecontrols", 1);
}

player_exit_level() {
  self allowstand(1);
  self allowcrouch(0);
  self allowprone(0);
}

player_killed_override(einflictor, attacker, idamage, smeansofdeath, weapon, vdir, shitloc, psoffsettime, deathanimduration) {
  level waittill(#"forever");
}

screen_fade_in(n_time, v_color, str_menu_id, var_b675738a = 0) {
  lui::screen_fade(n_time, 0, 1, v_color, 0, str_menu_id, var_b675738a);
  wait n_time;
}

player_intermission() {
  self closeingamemenu();
  self closemenu("StartMenu_Main");
  self notify(#"player_intermission");
  self endon(#"player_intermission", #"disconnect", #"death");
  level endon(#"stop_intermission");
  self notify(#"_zombie_game_over");

  if(!isDefined(self.score_total)) {
    self.score_total = 0;
  }

  self.score = self.score_total;
  points = struct::get_array("intermission", "targetname");

  if(!isDefined(points) || points.size == 0) {
    points = getEntArray("info_intermission", "classname");

    if(points.size < 1) {
      println("<dev string:x2e1>");
      return;
    }
  }

  if(isDefined(level.b_show_single_intermission) && level.b_show_single_intermission) {
    a_s_temp_points = array::randomize(points);
    points = [];
    points[0] = array::random(a_s_temp_points);
  } else {
    points = array::randomize(points);
  }

  self zm_utility::create_streamer_hint(points[0].origin, points[0].angles, 0.9);
  wait 5;
  self lui::screen_fade_out(1, undefined, undefined, 1);
  self.sessionstate = "intermission";
  self.spectatorclient = -1;
  self.killcamentity = -1;
  self.archivetime = 0;
  self.psoffsettime = 0;
  self.friendlydamage = undefined;

  if(isDefined(level.player_intemission_spawn_callback)) {
    self thread[[level.player_intemission_spawn_callback]](points[0].origin, points[0].angles);
  }

  while(true) {
    for(i = 0; i < points.size; i++) {
      point = points[i];
      nextpoint = points[i + 1];
      self setorigin(point.origin);
      self setplayerangles(point.angles);
      wait 0.15;
      self notify(#"player_intermission_spawned");

      if(isDefined(nextpoint)) {
        self zm_utility::create_streamer_hint(nextpoint.origin, nextpoint.angles, 0.9);
        self screen_fade_in(2, undefined, undefined, 1);
        wait 3;
        self lui::screen_fade_out(2, undefined, undefined, 1);
        continue;
      }

      self screen_fade_in(2, undefined, undefined, 1);

      if(points.size == 1) {
        return;
      }
    }
  }
}

zm_on_player_connect() {
  self.hitsoundtracker = 1;
  thread update_is_player_valid();
  characterindex = self getcharacterbodytype();
  self stats::function_7a850245(#"characterindex", characterindex);
}

zm_on_player_spawned() {
  self setperk("specialty_sprint");
  self setperk("specialty_sprintreload");
  self setperk("specialty_slide");
  thread zm_utility::update_zone_name();
}

update_is_player_valid() {
  self notify("48751ec765e7e853");
  self endon("48751ec765e7e853");
  self endon(#"disconnect");
  self.am_i_valid = 0;

  while(isDefined(self)) {
    self.am_i_valid = zm_utility::is_player_valid(self, 1);
    waitframe(1);
  }
}

register_slowdown(str_type, n_rate, n_duration) {
  if(!isDefined(level.var_f27112f9)) {
    level.var_f27112f9 = [];
  } else if(!isarray(level.var_f27112f9)) {
    level.var_f27112f9 = array(level.var_f27112f9);
  }

  level.var_f27112f9[str_type] = spawnStruct();
  level.var_f27112f9[str_type].n_rate = n_rate;
  level.var_f27112f9[str_type].n_duration = n_duration;
}

slowdown(str_type, var_a47cf2b2) {
  if(isDefined(self.var_7b0667d9) && self.var_7b0667d9) {
    return;
  }

  self notify(#"hash_31eac0065ba118f5");
  self endoncallback(&function_fe7a7d5b, #"hash_31eac0065ba118f5", #"death", #"hash_28af7943f07d93e2");
  assert(isDefined(level.var_f27112f9[str_type]), "<dev string:x306>" + str_type + "<dev string:x313>");

  if(!isDefined(self.a_n_slowdown_timeouts)) {
    self.a_n_slowdown_timeouts = [];
  }

  n_time = gettime();

  if(isDefined(level.var_f27112f9[str_type].n_duration)) {
    n_timeout = n_time + level.var_f27112f9[str_type].n_duration;

    if(!isDefined(self.a_n_slowdown_timeouts[str_type]) || self.a_n_slowdown_timeouts[str_type] < n_timeout) {
      self.a_n_slowdown_timeouts[str_type] = n_timeout;
    }
  } else {
    self.a_n_slowdown_timeouts[str_type] = -1;
  }

  while(self.a_n_slowdown_timeouts.size) {
    str_lowest_type = undefined;
    n_lowest_rate = 10;

    foreach(str_index, n_slowdown_timeout in self.a_n_slowdown_timeouts) {
      if(isDefined(n_timeout) && n_slowdown_timeout <= n_time) {
        self.a_n_slowdown_timeouts[str_index] = undefined;
        continue;
      }

      if(str_index == str_type && isDefined(var_a47cf2b2)) {
        n_rate = var_a47cf2b2;
      } else {
        n_rate = level.var_f27112f9[str_index].n_rate;
      }

      if(n_rate < n_lowest_rate) {
        str_lowest_type = str_index;
        n_lowest_rate = n_rate;
      }
    }

    if(isDefined(str_lowest_type)) {
      self setmovespeedscale(n_lowest_rate);

      if(!isDefined(n_timeout)) {
        self waittill(#"hash_28af7943f07d93e2");
        return;
      }

      n_duration = self.a_n_slowdown_timeouts[str_lowest_type] - n_time;
      wait n_duration;
      self.a_n_slowdown_timeouts[str_lowest_type] = undefined;
    }
  }

  self setmovespeedscale(1);
}

function_520f4da5() {
  self notify(#"hash_28af7943f07d93e2");
}

private function_fe7a7d5b(str_notify) {
  self setmovespeedscale(1);
}